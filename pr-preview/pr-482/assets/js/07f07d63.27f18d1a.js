"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[386],{245(e,s,n){n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Design","title":"Seal Design","description":"Learn how Seal uses Identity-Based Encryption (IBE) to provide secure, policy-driven data encryption with decentralized key management on Sui.","source":"@site/../content/Design.mdx","sourceDirName":".","slug":"/Design","permalink":"/Design","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Seal Design","description":"Learn how Seal uses Identity-Based Encryption (IBE) to provide secure, policy-driven data encryption with decentralized key management on Sui.","keywords":["Seal design","identity-based encryption","IBE","key servers","access policies","time-lock encryption","MPC committee","threshold encryption","decentralization"]},"sidebar":"docsSidebar","previous":{"title":"Seal Server Overview","permalink":"/ServerOverview"},"next":{"title":"Using Seal","permalink":"/UsingSeal"}}');var t=n(2615),r=n(7545);const a={title:"Seal Design",description:"Learn how Seal uses Identity-Based Encryption (IBE) to provide secure, policy-driven data encryption with decentralized key management on Sui.",keywords:["Seal design","identity-based encryption","IBE","key servers","access policies","time-lock encryption","MPC committee","threshold encryption","decentralization"]},c=void 0,o={},d=[{value:"Overview",id:"overview",level:2},{value:"Decentralization and trust model",id:"decentralization-and-trust-model",level:2},{value:"Key server",id:"key-server",level:2},{value:"User confirmation and sessions",id:"user-confirmation-and-sessions",level:2},{value:"Cryptographic primitives",id:"cryptographic-primitives",level:2}];function l(e){const s={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:["For a comprehensive technical analysis and formal security proofs, see the ",(0,t.jsx)(s.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(8065).A+"",children:"Seal Whitepaper"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(s.p,{children:["Seal uses a cryptographic primitive called ",(0,t.jsx)(s.em,{children:"Identity-Based Encryption (IBE)"})," to encrypt stored data. This design detail is abstracted away from both developers and users, as Seal does not have visibility into the data it helps secure."]}),"\n",(0,t.jsxs)(s.p,{children:["An ",(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Identity-based_encryption",children:"IBE scheme"})," consists of the following algorithms:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Setup"}),": Generates a master secret key ",(0,t.jsx)(s.code,{children:"msk"})," and a master public key ",(0,t.jsx)(s.code,{children:"mpk"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Derive(msk, id)"}),": Given a master secret key and an identity ",(0,t.jsx)(s.code,{children:"id"})," (string or byte array), generates a derived secret key ",(0,t.jsx)(s.code,{children:"sk"})," for that identity."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Encrypt(mpk, id, m)"}),": Given a public key, an identity, and a message, returns an encryption ",(0,t.jsx)(s.code,{children:"c"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Decrypt(sk, c)"}),": Given a derived secret key and a ciphertext, compute the message ",(0,t.jsx)(s.code,{children:"m"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Such a scheme is correct if for any ",(0,t.jsx)(s.code,{children:"id"})," and ",(0,t.jsx)(s.code,{children:"m"}),", ",(0,t.jsx)(s.code,{children:"(msk, mpk) \u2190 Setup()"})," and ",(0,t.jsx)(s.code,{children:"c \u2190 Encrypt(mpk, id, m)"})," we have ",(0,t.jsx)(s.code,{children:"Decrypt(Derive(msk, id), c) = m"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"The domain of identities is not fixed and can be any string or byte array. Seal uses this property to bound on-chain strings to IBE identities."}),"\n",(0,t.jsx)(s.p,{children:"Seal consists of two main components:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Access policies defined on Sui:"})," A Move package at address ",(0,t.jsx)(s.code,{children:"PkgId"})," controls the subdomain of IBE identities that starts with ",(0,t.jsx)(s.code,{children:"[PkgId]"})," (that is, all strings of the form ",(0,t.jsx)(s.code,{children:"[PkgId]*"}),"). You can think of ",(0,t.jsx)(s.code,{children:"[PkgId]"})," as an identity ",(0,t.jsx)(s.em,{children:"namespace"}),". The package defines, through Move code, who is authorized to access the keys associated with its identity subdomain."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"off-chain key servers:"})," Key servers are off-chain services, each holding a single IBE master secret key. Users can request a derived secret key for a specific identity. The key server returns the derived key only if the associated on-chain access policy approves the request."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Consider the following basic example for realizing time-lock encryption:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"module patterns::tle;\n\nuse sui::bcs;\nuse sui::clock;\n\nconst ENoAccess : u64 = 1;\n\n/////////////////////////////////////////////\n/// Access control\n/// The IBE identity being used: [pkg id][bcs::to_bytes(time)]\n/// The following function accepts only the inner identity, i.e., [bcs::to_bytes(time)], and Seal extends it with the namespace.\nentry fun seal_approve(id: vector<u8>, c: &clock::Clock) {\n    // Convert the identity to u64.\n    let mut prepared: BCS = bcs::new(id);\n    let t = prepared.peel_u64();\n    let leftovers = prepared.into_remainder_bytes();\n\n    // Check that the time has passed and the entire identity is consumed.\n    assert!((leftovers.length() == 0) && (c.timestamp_ms() >= t), ENoAccess);\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The module controls all IBE identities that begin with its package ID ",(0,t.jsx)(s.code,{children:"PkgId"}),". To encrypt data with a time-lock ",(0,t.jsx)(s.code,{children:"T"}),", a user selects a key server and encrypts the data using the identity ",(0,t.jsx)(s.code,{children:"[PkgId][bcs::to_bytes(T)]"})," and the server's IBE master public key. Once the on-chain time on Sui exceeds ",(0,t.jsx)(s.code,{children:"T"}),", anyone can request the decryption key for the identity ",(0,t.jsx)(s.code,{children:"[PkgId][bcs::to_bytes(T)]"})," from the Seal key server. Access control is enforced by the ",(0,t.jsx)(s.code,{children:"seal_approve"})," function defined in the module. This function receives the requested identity (excluding the ",(0,t.jsx)(s.code,{children:"PkgId"})," prefix) and a ",(0,t.jsx)(s.code,{children:"Clock"})," as arguments. It returns success only if the current time is greater than or equal to ",(0,t.jsx)(s.code,{children:"T"}),". The key server evaluates ",(0,t.jsx)(s.code,{children:"seal_approve"})," to determine whether the derived key can be returned."]}),"\n",(0,t.jsxs)(s.p,{children:["Time-lock encryption can be applied to a variety of on-chain use cases, including MEV-resistant trading, secure voting, and more. For additional examples and useful implementation patterns, see ",(0,t.jsx)(s.a,{href:"/ExamplePatterns",children:"Example patterns"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The framework is fully generic. Developers can define custom authorization logic within ",(0,t.jsx)(s.code,{children:"seal_approve*"})," functions and choose which key servers to use based on their application's needs. For example, they can use a fixed set of trusted key servers or allow users to select their preferred servers."]}),"\n",(0,t.jsxs)(s.p,{children:["When you upgrade a package, it retains the same identity subdomain. To support secure upgrades, follow the recommended best practices for ",(0,t.jsx)(s.a,{href:"https://docs.sui.io/concepts/sui-move-concepts/packages/upgrade#versioned-shared-objects",children:"versioned shared objects"}),". Specifically, version your shared objects, or create a global versioned shared object for your package. For examples, see the ",(0,t.jsx)(s.a,{href:"/ExamplePatterns",children:"allowlist and subscription patterns"}),". Keep in mind that if a package is upgradeable, the access control policy can be changed at any time by the package owner. These changes are transparent and publicly visible on-chain."]}),"\n",(0,t.jsx)(s.h2,{id:"decentralization-and-trust-model",children:"Decentralization and trust model"}),"\n",(0,t.jsx)(s.p,{children:"Seal is designed to reduce centralization using a couple of mechanisms."}),"\n",(0,t.jsxs)(s.p,{children:["First, users can choose any combination of one or more key servers and use their master public keys to encrypt data. This setup supports ",(0,t.jsx)(s.code,{children:"t-out-of-n"})," threshold encryption, which ensures:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Privacy"})," as long as fewer than ",(0,t.jsx)(s.code,{children:"t"})," key servers are compromised."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Liveness"})," as long as at least ",(0,t.jsx)(s.code,{children:"t"})," key servers are available."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Seal does not mandate the use of any specific key server. Instead, users can select key servers based on their own trust assumptions. Key servers can vary in security characteristics, such as running within secure enclaves or being air-gapped, and can operate across different locations and jurisdictions."}),"\n",(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsx)(s.p,{children:"The set of key servers is not dynamic once the data is encrypted, and encrypted data cannot be changed to use a different set of servers."})}),"\n",(0,t.jsxs)(s.p,{children:["Second, a single key server can also be implemented using a multi-party computation (MPC) committee in a ",(0,t.jsx)(s.code,{children:"t-out-of-n"})," configuration. This committee can consist of Sui validators or any other group of participants. This mechanism is not yet available, but MPC-based key servers are expected to be deployed in the near future. Users can choose to use these in addition to standalone key servers. In this setup, the participants in the MPC committee can change over time, allowing for dynamic membership."]}),"\n",(0,t.jsx)(s.p,{children:"The security of encrypted data relies on the following assumptions:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Key server integrity"}),": The Seal key servers are not compromised, or, in the case of threshold encryption, fewer than the required threshold are compromised. This includes both the Seal key servers and the Sui full nodes they depend on to evaluate the access policies."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Correct access control policy"}),": The access control policy associated with the encrypted data is accurate and appropriately configured. If package upgrades are enabled, the package owner can modify the policy at any time."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"key-server",children:"Key server"}),"\n",(0,t.jsx)(s.p,{children:"A light server is initialized with an identity-based encryption (IBE) master secret key and has access to a trusted full node. In simple deployments, the server runs as a backend service with the secret key stored in protected storage, optionally secured using a software or hardware vault. More advanced deployments can use secure enclaves, MPC committees, or even air-gapped environments to enhance security."}),"\n",(0,t.jsx)(s.p,{children:"The server exposes only two APIs:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"/v1/service"})," - Returns information about the service's on-chain registered information."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"/v1/fetch_key"})," - Handles a request for one or more derived keys and returns them if access is permitted by the associated package or policies. Each request must meet the following requirements:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Be signed by the user's address using ",(0,t.jsx)(s.code,{children:"signPersonalMessage"}),". For details, see the ",(0,t.jsx)(s.a,{href:"https://github.com/MystenLabs/seal/tree/main/crates/key-server/src/signed_message.rs",children:"signed_message"})," format."]}),"\n",(0,t.jsxs)(s.li,{children:["Include a valid PTB, which is evaluated against the ",(0,t.jsx)(s.code,{children:"seal_approve*"})," rules. For PTB construction guidelines, see ",(0,t.jsx)(s.a,{href:"https://github.com/MystenLabs/seal/tree/main/crates/key-server/src/valid_ptb.rs",children:"valid_ptb"}),"."]}),"\n",(0,t.jsx)(s.li,{children:"Provide an ephemeral encryption key to encrypt the response. Encrypting the response ensures that only the requester (the initiator) can decrypt and access the returned keys."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["See ",(0,t.jsx)(s.a,{href:"https://github.com/MystenLabs/seal/tree/main/crates/key-server/src/server.rs",children:"crates/key-server"})," for the implementation of the key server."]}),"\n",(0,t.jsx)(s.h2,{id:"user-confirmation-and-sessions",children:"User confirmation and sessions"}),"\n",(0,t.jsxs)(s.p,{children:["Decryption keys returned from the key server are returned directly to the caller, which is typically the dApp's web page. To ensure that dApps can access only keys explicitly approved by the user, the user must approve the key access request in their wallet. This approval is granted once per package and authorizes a ",(0,t.jsx)(s.code,{children:"session key"}),". The session key allows the dApp to retrieve associated decryption keys for a limited time without requiring repeated user confirmations."]}),"\n",(0,t.jsx)(s.h2,{id:"cryptographic-primitives",children:"Cryptographic primitives"}),"\n",(0,t.jsx)(s.p,{children:"Seal is designed to support multiple identity-based encryption (IBE) schemes as Key Encapsulation Mechanisms (KEMs) and various symmetric encryption schemes as Data Encapsulation Mechanisms (DEMs). Currently supported primitives include:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"KEM"}),": Boneh-Franklin IBE with the BLS12-381 curve."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"DEM"}),": AES-256-GCM, HMAC based CTR mode."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Prefer ",(0,t.jsx)(s.code,{children:"AES-256-GCM"})," for most use cases as it is faster. Use ",(0,t.jsx)(s.code,{children:"HMAC-CTR"})," only when you require on-chain decryption."]}),"\n",(0,t.jsx)(s.p,{children:"Post-quantum primitives are planned to be added in the future."}),"\n",(0,t.jsx)(s.p,{children:"For advanced encryption schemes, use Seal as a KMS to protect the scheme's secret key. This approach enables streaming, hardware-assisted, or chunked decryption while keeping keys out of application code."})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8065(e,s,n){n.d(s,{A:()=>i});const i=n.p+"assets/files/Seal_White_Paper_v1-c9370b2648a548b7b2e0b1c5d73ee49e.pdf"},7545(e,s,n){n.d(s,{R:()=>a,x:()=>c});var i=n(9471);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);