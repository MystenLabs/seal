"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[446],{5729(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"ExamplePatterns","title":"Access Policy Example Patterns","description":"Explore common Seal access policy patterns including private data, allowlists, subscriptions, time-lock encryption, and secure voting implementations.","source":"@site/../content/ExamplePatterns.mdx","sourceDirName":".","slug":"/ExamplePatterns","permalink":"/ExamplePatterns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Access Policy Example Patterns","description":"Explore common Seal access policy patterns including private data, allowlists, subscriptions, time-lock encryption, and secure voting implementations.","keywords":["access policy","Seal patterns","private data","allowlist","subscription","time-lock encryption","secure voting","encrypted content","IBE"]},"sidebar":"docsSidebar","previous":{"title":"Using Seal","permalink":"/UsingSeal"},"next":{"title":"Security Best Practices and Risk Mitigations","permalink":"/SecurityBestPractices"}}');var i=n(4848),a=n(8453);const o={title:"Access Policy Example Patterns",description:"Explore common Seal access policy patterns including private data, allowlists, subscriptions, time-lock encryption, and secure voting implementations.",keywords:["access policy","Seal patterns","private data","allowlist","subscription","time-lock encryption","secure voting","encrypted content","IBE"]},r="Access policy example patterns",c={},l=[{value:"Private data",id:"private-data",level:2},{value:"Allowlist",id:"allowlist",level:2},{value:"Subscription",id:"subscription",level:2},{value:"Time-lock encryption",id:"time-lock-encryption",level:2},{value:"Variation - pre-signed URLs",id:"variation---pre-signed-urls",level:3},{value:"Secure voting",id:"secure-voting",level:2}];function p(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"access-policy-example-patterns",children:"Access policy example patterns"})}),"\n",(0,i.jsxs)(t.p,{children:["This page summarizes common Seal patterns from the ",(0,i.jsx)(t.a,{href:"https://github.com/MystenLabs/seal/tree/main/move/patterns/sources",children:"Move patterns repository"}),". It is not exhaustive. For additional patterns and the latest updates, see the repository directly."]}),"\n",(0,i.jsx)(t.h2,{id:"private-data",children:"Private data"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/MystenLabs/seal/blob/main/move/patterns/sources/private_data.move",children:"Move source"})}),"\n",(0,i.jsx)(t.p,{children:"Use this pattern when a single owner should control encrypted content. You store the ciphertext as an owned object. Only the current owner can decrypt, and ownership transfer moves custody without exposing the data. This pattern is a good fit for personal key storage, private NFTs, or user-held credentials that must remain private yet portable."}),"\n",(0,i.jsx)(t.h2,{id:"allowlist",children:"Allowlist"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/MystenLabs/seal/blob/main/move/patterns/sources/whitelist.move",children:"Move source"})}),"\n",(0,i.jsx)(t.p,{children:"Use this pattern to share encrypted content with a defined group or list of approved users. You manage access by adding or removing members on the list, and those changes apply to future decryptions without touching the encrypted data. This pattern works well for subscriptions, partner-only data rooms, or early-access drops, and can optionally switch to public access after a set time."}),"\n",(0,i.jsx)(t.h2,{id:"subscription",children:"Subscription"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/MystenLabs/seal/blob/main/move/patterns/sources/subscription.move",children:"Move source"})}),"\n",(0,i.jsx)(t.p,{children:"Use this pattern to offer time-limited access to encrypted content or services. You define a service with a price and duration. When someone subscribes, their identity gets a pass that lets them decrypt the service's content until it expires. There is no need to re-encrypt or move data. This pattern is ideal for premium media, data feeds, or paid API and AI model access."}),"\n",(0,i.jsx)(t.h2,{id:"time-lock-encryption",children:"Time-lock encryption"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/MystenLabs/seal/blob/main/move/patterns/sources/tle.move",children:"Move source"})}),"\n",(0,i.jsx)(t.p,{children:"Use this pattern to publish encrypted content that unlocks automatically at a specific time. You encrypt once with an unlock timestamp. Before that moment, no one can open it, and after it passes, anyone (or your intended audience) can. No re-encryption or per-user distribution is needed. This pattern is ideal for coordinated reveals (drops, auctions), MEV-resilient trading, and secure voting. An optional variant lets an authorized party extend the unlock time before it expires."}),"\n",(0,i.jsx)(t.h3,{id:"variation---pre-signed-urls",children:"Variation - pre-signed URLs"}),"\n",(0,i.jsxs)(t.p,{children:['Apply the same time-based logic to gate a specific Walrus blob behind a time-limited link that expires. Encrypt once (optionally bind the blob ID in the key ID), include an expiry parameter, and let the policy authorize decrypts only before the deadline, not after. To emulate cloud "signed URLs" more closely, combine the time check with an access rule (for example, an ',(0,i.jsx)(t.a,{href:"#allowlist",children:"allowlist"})," or ",(0,i.jsx)(t.a,{href:"#subscription",children:"subscription"})," check)."]}),"\n",(0,i.jsx)(t.p,{children:"This section covers access control, not link generation. You can generate and distribute the URL off-chain, or add a helper function in the same access policy package to produce or validate link parameters if you prefer to keep it on-chain. This enables limited-time downloads without re-encrypting content or managing per-user copies."}),"\n",(0,i.jsx)(t.h2,{id:"secure-voting",children:"Secure voting"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/MystenLabs/seal/blob/main/move/patterns/sources/voting.move",children:"Move source"})}),"\n",(0,i.jsxs)(t.p,{children:["Use this pattern to run a vote where ballots stay encrypted until completion. You define eligible voters and each submits an encrypted choice. When all votes are in, anyone can fetch the required threshold keys from Seal and use the ",(0,i.jsx)(t.a,{href:"https://seal-docs.wal.app/UsingSeal/#on-chain-decryption",children:"on-chain decryption"})," to produce a verifiable tally. Invalid or tampered ballots are ignored. This pattern is useful for governance, sealed-bid auctions, or time-locked voting."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453(e,t,n){n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);