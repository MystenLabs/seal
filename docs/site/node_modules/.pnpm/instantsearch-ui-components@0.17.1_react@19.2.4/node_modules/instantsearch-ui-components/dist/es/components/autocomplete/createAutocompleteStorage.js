import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _typeof from "@babel/runtime/helpers/typeof";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { find } from "../../lib/index.js";
export function createAutocompleteStorage(_ref) {
  var useEffect = _ref.useEffect,
    useMemo = _ref.useMemo,
    useState = _ref.useState;
  return function useStorage(_ref2) {
    var showRecent = _ref2.showRecent,
      query = _ref2.query,
      indices = _ref2.indices,
      indicesConfig = _ref2.indicesConfig,
      suggestionsIndexName = _ref2.suggestionsIndexName;
    var storageKey = showRecent && _typeof(showRecent) === 'object' ? showRecent.storageKey : undefined;
    var storage = useMemo(function () {
      return createStorage({
        limit: 5,
        storageKey: storageKey
      });
    }, [storageKey]);
    var _useState = useState(storage.getSnapshot()),
      _useState2 = _slicedToArray(_useState, 2),
      snapshot = _useState2[0],
      setSnapshot = _useState2[1];
    useEffect(function () {
      storage.registerUpdateListener(function () {
        setSnapshot(storage.getSnapshot());
      });
      return function () {
        storage.unregisterUpdateListener();
      };
    }, [storage]);
    if (!showRecent) {
      return {
        storage: {
          onAdd: function onAdd() {},
          onRemove: function onRemove() {}
        },
        storageHits: [],
        indicesForPropGetters: indices,
        indicesConfigForPropGetters: indicesConfig
      };
    }
    var storageHits = snapshot.getAll(query).map(function (value) {
      return {
        objectID: value,
        query: value,
        __indexName: 'recent-searches',
        _highlightResult: getHighlightedAttribute({
          item: {
            query: value
          },
          query: query || ''
        })
      };
    });
    var indicesForPropGetters = _toConsumableArray(indices.map(function (index) {
      return index.indexName === suggestionsIndexName ? _objectSpread(_objectSpread({}, index), {}, {
        hits: index.hits.filter(function (hit) {
          return !find(storageHits, function (storageHit) {
            return storageHit.query === hit.query;
          });
        })
      }) : index;
    }));
    var indicesConfigForPropGetters = _toConsumableArray(indicesConfig);
    indicesForPropGetters.unshift({
      indexName: 'recent-searches',
      indexId: 'recent-searches',
      hits: storageHits
    });
    indicesConfigForPropGetters.unshift({
      indexName: 'recent-searches',
      // @ts-expect-error - we know it has query as it's generated from storageHits
      getQuery: function getQuery(item) {
        return item.query;
      }
    });
    return {
      storage: storage,
      storageHits: storageHits,
      indicesForPropGetters: indicesForPropGetters,
      indicesConfigForPropGetters: indicesConfigForPropGetters
    };
  };
}
var LOCAL_STORAGE_KEY_TEST = 'test-localstorage-support';
var LOCAL_STORAGE_KEY = 'autocomplete-recent-searches';
function isLocalStorageSupported() {
  try {
    localStorage.setItem(LOCAL_STORAGE_KEY_TEST, '');
    localStorage.removeItem(LOCAL_STORAGE_KEY_TEST);
    return true;
  } catch (error) {
    return false;
  }
}
function getHighlightedAttribute(_ref3) {
  var item = _ref3.item,
    query = _ref3.query;
  if (!query.trim().length) {
    return {
      query: {
        matchLevel: 'none'
      }
    };
  }
  return {
    query: {
      value: item.query.replace(new RegExp(query.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi'), function (match) {
        return "<mark>".concat(match, "</mark>");
      })
    }
  };
}
function getLocalStorage() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LOCAL_STORAGE_KEY;
  if (!isLocalStorageSupported()) {
    return {
      setItems: function setItems() {},
      getItems: function getItems() {
        return [];
      }
    };
  }
  return {
    setItems: function setItems(items) {
      try {
        window.localStorage.setItem(key, JSON.stringify(items));
      } catch (_unused) {
        // do nothing, this likely means the storage is full
      }
    },
    getItems: function getItems() {
      var items = window.localStorage.getItem(key);
      return items ? JSON.parse(items) : [];
    }
  };
}
export function createStorage(_ref4) {
  var _ref4$limit = _ref4.limit,
    limit = _ref4$limit === void 0 ? 5 : _ref4$limit,
    storageKey = _ref4.storageKey;
  var storage = getLocalStorage(storageKey);
  var updateListener = null;
  return {
    onAdd: function onAdd(query) {
      this.onRemove(query);
      storage.setItems([query].concat(_toConsumableArray(storage.getItems())));
    },
    onRemove: function onRemove(query) {
      var _updateListener;
      storage.setItems(storage.getItems().filter(function (q) {
        return q !== query;
      }));
      (_updateListener = updateListener) === null || _updateListener === void 0 ? void 0 : _updateListener();
    },
    registerUpdateListener: function registerUpdateListener(callback) {
      updateListener = callback;
    },
    unregisterUpdateListener: function unregisterUpdateListener() {
      updateListener = null;
    },
    getSnapshot: function getSnapshot() {
      return {
        getAll: function getAll() {
          var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          return storage.getItems().filter(function (q) {
            return q.includes(query);
          }).slice(0, limit);
        }
      };
    }
  };
}