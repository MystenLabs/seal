var _excluded = ["messageId"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/* eslint-disable @typescript-eslint/consistent-type-assertions */
import { processStream } from "./stream-parser.js";
import { generateId as defaultGenerateId, SerialJobExecutor } from "./utils.js";
/**
 * Abstract base class for chat implementations.
 */
export var AbstractChat = /*#__PURE__*/function () {
  function AbstractChat(_ref) {
    var _this = this;
    var _ref$generateId = _ref.generateId,
      generateId = _ref$generateId === void 0 ? defaultGenerateId : _ref$generateId,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? generateId() : _ref$id,
      transport = _ref.transport,
      state = _ref.state,
      onError = _ref.onError,
      onToolCall = _ref.onToolCall,
      onFinish = _ref.onFinish,
      onData = _ref.onData,
      sendAutomaticallyWhen = _ref.sendAutomaticallyWhen;
    _classCallCheck(this, AbstractChat);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "generateId", void 0);
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "transport", void 0);
    _defineProperty(this, "onError", void 0);
    _defineProperty(this, "onToolCall", void 0);
    _defineProperty(this, "onFinish", void 0);
    _defineProperty(this, "onData", void 0);
    _defineProperty(this, "sendAutomaticallyWhen", void 0);
    _defineProperty(this, "activeResponse", null);
    _defineProperty(this, "jobExecutor", new SerialJobExecutor());
    /**
     * Appends or replaces a user message to the chat list. This triggers the API call to fetch
     * the assistant's response.
     */
    _defineProperty(this, "sendMessage", function (message, options) {
      return _this.jobExecutor.run(function () {
        // Build the user message
        var userMessagePromise;
        if (message) {
          var messageId = message.messageId || _this.generateId();
          if ('parts' in message && message.parts) {
            // Full message with parts provided
            userMessagePromise = Promise.resolve(_objectSpread({
              id: messageId,
              role: 'user'
            }, message));
          } else if ('text' in message && message.text) {
            // Build from text
            var parts = [{
              type: 'text',
              text: message.text
            }];

            // Add file parts if provided
            if (message.files) {
              userMessagePromise = _this.convertFilesToParts(message.files).then(function (fileParts) {
                parts.push.apply(parts, _toConsumableArray(fileParts));
                return {
                  id: messageId,
                  role: 'user',
                  parts: parts,
                  metadata: message.metadata
                };
              });
            } else {
              userMessagePromise = Promise.resolve({
                id: messageId,
                role: 'user',
                parts: parts,
                metadata: message.metadata
              });
            }
          } else if ('files' in message && message.files) {
            // Files only
            userMessagePromise = _this.convertFilesToParts(message.files).then(function (fileParts) {
              return {
                id: messageId,
                role: 'user',
                parts: fileParts,
                metadata: message.metadata
              };
            });
          } else {
            userMessagePromise = Promise.resolve(undefined);
          }
        } else {
          userMessagePromise = Promise.resolve(undefined);
        }
        return userMessagePromise.then(function (userMessage) {
          if (userMessage) {
            _this.state.pushMessage(userMessage);
          }
          return _this.makeRequest(_objectSpread({
            trigger: 'submit-message',
            messageId: userMessage === null || userMessage === void 0 ? void 0 : userMessage.id
          }, options));
        });
      });
    });
    /**
     * Regenerate the assistant message with the provided message id.
     * If no message id is provided, the last assistant message will be regenerated.
     */
    _defineProperty(this, "regenerate", function () {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        messageId = _ref2.messageId,
        options = _objectWithoutProperties(_ref2, _excluded);
      return _this.jobExecutor.run(function () {
        // Find the message to regenerate from
        var targetIndex = -1;
        if (messageId) {
          targetIndex = _this.state.messages.findIndex(function (m) {
            return m.id === messageId;
          });
        } else {
          // Find the last assistant message
          for (var i = _this.state.messages.length - 1; i >= 0; i--) {
            if (_this.state.messages[i].role === 'assistant') {
              targetIndex = i;
              break;
            }
          }
        }
        if (targetIndex >= 0) {
          // Remove the assistant message and all messages after it
          _this.state.messages = _this.state.messages.slice(0, targetIndex);
        }
        return _this.makeRequest(_objectSpread({
          trigger: 'regenerate-message',
          messageId: messageId
        }, options));
      });
    });
    /**
     * Attempt to resume an ongoing streaming response.
     */
    _defineProperty(this, "resumeStream", function (options) {
      return _this.jobExecutor.run(function () {
        if (!_this.transport) {
          return Promise.reject(new Error('Transport is required for resuming stream. Please provide a transport when initializing the chat.'));
        }
        _this.setStatus({
          status: 'submitted'
        });
        return _this.transport.reconnectToStream(_objectSpread({
          chatId: _this.id
        }, options)).then(function (stream) {
          if (stream) {
            return _this.processStreamWithCallbacks(stream);
          } else {
            _this.setStatus({
              status: 'ready'
            });
            return Promise.resolve();
          }
        }, function (error) {
          _this.handleError(error);
          return Promise.resolve();
        });
      });
    });
    /**
     * Clear the error state and set the status to ready if the chat is in an error state.
     */
    _defineProperty(this, "clearError", function () {
      if (_this.state.status === 'error') {
        _this.setStatus({
          status: 'ready',
          error: undefined
        });
      }
    });
    /**
     * Add a tool result for a tool call.
     */
    _defineProperty(this, "addToolResult", function (_ref3) {
      var tool = _ref3.tool,
        toolCallId = _ref3.toolCallId,
        output = _ref3.output;
      return _this.jobExecutor.run(function () {
        // Find the message with this tool call
        var messageIndex = _this.state.messages.findIndex(function (m) {
          var _m$parts$some, _m$parts;
          return (_m$parts$some = (_m$parts = m.parts) === null || _m$parts === void 0 ? void 0 : _m$parts.some(function (p) {
            return 'toolCallId' in p && p.toolCallId === toolCallId || 'type' in p && p.type === "tool-".concat(String(tool));
          })) !== null && _m$parts$some !== void 0 ? _m$parts$some : false;
        });
        if (messageIndex === -1) return Promise.resolve();
        var message = _this.state.messages[messageIndex];
        var updatedParts = message.parts.map(function (part) {
          if ('toolCallId' in part && part.toolCallId === toolCallId && 'state' in part) {
            return _objectSpread(_objectSpread({}, part), {}, {
              state: 'output-available',
              output: output
            });
          }
          return part;
        });
        _this.state.replaceMessage(messageIndex, _objectSpread(_objectSpread({}, message), {}, {
          parts: updatedParts
        }));

        // Check if we should auto-send based on sendAutomaticallyWhen
        if (_this.sendAutomaticallyWhen) {
          return Promise.resolve(_this.sendAutomaticallyWhen({
            messages: _this.state.messages
          })).then(function (shouldSend) {
            if (shouldSend) {
              return _this.makeRequest({
                trigger: 'submit-message'
              });
            }
            return Promise.resolve();
          });
        }
        return Promise.resolve();
      });
    });
    /**
     * Abort the current request immediately, keep the generated tokens if any.
     */
    _defineProperty(this, "stop", function () {
      if (_this.activeResponse) {
        _this.activeResponse.abortController.abort();
        _this.activeResponse = null;
      }
      _this.setStatus({
        status: 'ready'
      });
      return Promise.resolve();
    });
    this.id = id;
    this.generateId = generateId;
    this.state = state;
    this.transport = transport;
    this.onError = onError;
    this.onToolCall = onToolCall;
    this.onFinish = onFinish;
    this.onData = onData;
    this.sendAutomaticallyWhen = sendAutomaticallyWhen;
  }

  /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */
  _createClass(AbstractChat, [{
    key: "status",
    get: function get() {
      return this.state.status;
    }
  }, {
    key: "setStatus",
    value: function setStatus(_ref4) {
      var status = _ref4.status,
        error = _ref4.error;
      this.state.status = status;
      if (error !== undefined) {
        this.state.error = error;
      }
    }
  }, {
    key: "error",
    get: function get() {
      return this.state.error;
    }
  }, {
    key: "messages",
    get: function get() {
      return this.state.messages;
    },
    set: function set(messages) {
      this.state.messages = messages;
    }
  }, {
    key: "lastMessage",
    get: function get() {
      return this.state.messages[this.state.messages.length - 1];
    }
  }, {
    key: "makeRequest",
    value: function makeRequest(options) {
      var _this2 = this;
      if (!this.transport) {
        return Promise.reject(new Error('Transport is required for sending messages. Please provide a transport when initializing the chat.'));
      }

      // Abort any existing request
      if (this.activeResponse) {
        this.activeResponse.abortController.abort();
      }
      var abortController = new AbortController();
      this.activeResponse = {
        abortController: abortController
      };
      this.setStatus({
        status: 'submitted'
      });
      return this.transport.sendMessages({
        chatId: this.id,
        messages: this.state.messages,
        abortSignal: abortController.signal,
        trigger: options.trigger,
        messageId: options.messageId,
        headers: options.headers,
        body: options.body,
        requestMetadata: options.metadata
      }).then(function (stream) {
        _this2.activeResponse.stream = stream;
        return _this2.processStreamWithCallbacks(stream);
      }, function (error) {
        if (error.name === 'AbortError') {
          // Request was aborted, don't treat as error
          return Promise.resolve();
        }
        _this2.handleError(error);
        return Promise.resolve();
      });
    }
  }, {
    key: "processStreamWithCallbacks",
    value: function processStreamWithCallbacks(stream) {
      var _this3 = this;
      this.setStatus({
        status: 'streaming'
      });
      var currentMessageId;
      var currentMessage;
      var currentMessageIndex = -1;
      var isAbort = false;
      var isDisconnect = false;
      var isError = false;

      // Track current text/reasoning part state
      var currentTextPartId;
      var currentReasoningPartId;

      // Promise chain for handling tool calls that return promises
      var pendingToolCall = Promise.resolve();
      return new Promise(function (resolve) {
        processStream(stream,
        // eslint-disable-next-line complexity
        function (chunk) {
          switch (chunk.type) {
            case 'start':
              {
                currentMessageId = chunk.messageId || _this3.generateId();

                // Check if we're continuing an existing message or creating a new one
                var lastMessage = _this3.lastMessage;
                if (lastMessage && lastMessage.role === 'assistant' && lastMessage.id === currentMessageId) {
                  currentMessage = lastMessage;
                  currentMessageIndex = _this3.state.messages.length - 1;
                } else {
                  currentMessage = {
                    id: currentMessageId,
                    role: 'assistant',
                    parts: [],
                    metadata: chunk.messageMetadata
                  };
                  _this3.state.pushMessage(currentMessage);
                  currentMessageIndex = _this3.state.messages.length - 1;
                }
                break;
              }
            case 'text-start':
              {
                if (!currentMessage) break;
                currentTextPartId = chunk.id;
                var textPart = {
                  type: 'text',
                  text: '',
                  state: 'streaming',
                  providerMetadata: chunk.providerMetadata
                };
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: [].concat(_toConsumableArray(currentMessage.parts), [textPart])
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'text-delta':
              {
                if (!currentMessage || !currentTextPartId) break;
                var partIndex = currentMessage.parts.findIndex(function (p) {
                  return p.type === 'text' && p.state === 'streaming';
                });
                if (partIndex === -1) break;
                var updatedParts = _toConsumableArray(currentMessage.parts);
                var _textPart = updatedParts[partIndex];
                updatedParts[partIndex] = _objectSpread(_objectSpread({}, _textPart), {}, {
                  text: _textPart.text + chunk.delta
                });
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: updatedParts
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'text-end':
              {
                if (!currentMessage) break;
                var _partIndex = currentMessage.parts.findIndex(function (p) {
                  return p.type === 'text' && p.state === 'streaming';
                });
                if (_partIndex === -1) break;
                var _updatedParts = _toConsumableArray(currentMessage.parts);
                var _textPart2 = _updatedParts[_partIndex];
                _updatedParts[_partIndex] = _objectSpread(_objectSpread({}, _textPart2), {}, {
                  state: 'done'
                });
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: _updatedParts
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                currentTextPartId = undefined;
                break;
              }
            case 'reasoning-start':
              {
                if (!currentMessage) break;
                currentReasoningPartId = chunk.id;
                var reasoningPart = {
                  type: 'reasoning',
                  text: '',
                  state: 'streaming',
                  providerMetadata: chunk.providerMetadata
                };
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: [].concat(_toConsumableArray(currentMessage.parts), [reasoningPart])
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'reasoning-delta':
              {
                if (!currentMessage || !currentReasoningPartId) break;
                var _partIndex2 = currentMessage.parts.findIndex(function (p) {
                  return p.type === 'reasoning' && p.state === 'streaming';
                });
                if (_partIndex2 === -1) break;
                var _updatedParts2 = _toConsumableArray(currentMessage.parts);
                var _reasoningPart = _updatedParts2[_partIndex2];
                _updatedParts2[_partIndex2] = _objectSpread(_objectSpread({}, _reasoningPart), {}, {
                  text: _reasoningPart.text + chunk.delta
                });
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: _updatedParts2
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'reasoning-end':
              {
                if (!currentMessage) break;
                var _partIndex3 = currentMessage.parts.findIndex(function (p) {
                  return p.type === 'reasoning' && p.state === 'streaming';
                });
                if (_partIndex3 === -1) break;
                var _updatedParts3 = _toConsumableArray(currentMessage.parts);
                var _reasoningPart2 = _updatedParts3[_partIndex3];
                _updatedParts3[_partIndex3] = _objectSpread(_objectSpread({}, _reasoningPart2), {}, {
                  state: 'done'
                });
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: _updatedParts3
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                currentReasoningPartId = undefined;
                break;
              }
            case 'tool-input-start':
              {
                if (!currentMessage) break;
                var toolPart = {
                  type: "tool-".concat(chunk.toolName),
                  toolCallId: chunk.toolCallId,
                  state: 'input-streaming',
                  input: chunk.input,
                  providerExecuted: chunk.providerExecuted
                };
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: [].concat(_toConsumableArray(currentMessage.parts), [toolPart])
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'tool-input-delta':
              {
                // Tool input streaming - we'd need to parse partial JSON
                // For now, we'll wait for tool-input-available
                break;
              }
            case 'tool-input-available':
              {
                if (!currentMessage) break;

                // Find existing tool part or create new one
                var existingIndex = currentMessage.parts.findIndex(function (p) {
                  return 'toolCallId' in p && p.toolCallId === chunk.toolCallId;
                });
                var _toolPart = {
                  type: "tool-".concat(chunk.toolName),
                  toolCallId: chunk.toolCallId,
                  state: 'input-available',
                  input: chunk.input,
                  callProviderMetadata: chunk.callProviderMetadata,
                  providerExecuted: chunk.providerExecuted
                };
                if (existingIndex >= 0) {
                  var _updatedParts4 = _toConsumableArray(currentMessage.parts);
                  _updatedParts4[existingIndex] = _toolPart;
                  currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                    parts: _updatedParts4
                  });
                } else {
                  currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                    parts: [].concat(_toConsumableArray(currentMessage.parts), [_toolPart])
                  });
                }
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);

                // Trigger onToolCall callback only for client-executed tools
                // (server-executed tools have providerExecuted: true and don't need client handling)
                if (_this3.onToolCall && !chunk.providerExecuted) {
                  var result = _this3.onToolCall({
                    toolCall: {
                      toolName: chunk.toolName,
                      toolCallId: chunk.toolCallId,
                      input: chunk.input
                    }
                  });
                  if (result && typeof result.then === 'function') {
                    pendingToolCall = pendingToolCall.then(function () {
                      return result;
                    });
                  }
                }
                break;
              }
            case 'tool-output-available':
              {
                if (!currentMessage) break;
                var toolIndex = currentMessage.parts.findIndex(function (p) {
                  return 'toolCallId' in p && p.toolCallId === chunk.toolCallId;
                });
                if (toolIndex >= 0) {
                  var _updatedParts5 = _toConsumableArray(currentMessage.parts);
                  var existingPart = _updatedParts5[toolIndex];
                  _updatedParts5[toolIndex] = _objectSpread(_objectSpread({}, existingPart), {}, {
                    state: 'output-available',
                    output: chunk.output,
                    callProviderMetadata: chunk.callProviderMetadata,
                    preliminary: chunk.preliminary
                  });
                  currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                    parts: _updatedParts5
                  });
                  _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                }
                break;
              }
            case 'tool-error':
              {
                if (!currentMessage) break;
                var _toolIndex = currentMessage.parts.findIndex(function (p) {
                  return 'toolCallId' in p && p.toolCallId === chunk.toolCallId;
                });
                if (_toolIndex >= 0) {
                  var _chunk$input;
                  var _updatedParts6 = _toConsumableArray(currentMessage.parts);
                  var _existingPart = _updatedParts6[_toolIndex];
                  _updatedParts6[_toolIndex] = _objectSpread(_objectSpread({}, _existingPart), {}, {
                    state: 'output-error',
                    errorText: chunk.errorText,
                    input: (_chunk$input = chunk.input) !== null && _chunk$input !== void 0 ? _chunk$input : _existingPart.input,
                    callProviderMetadata: chunk.callProviderMetadata
                  });
                  currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                    parts: _updatedParts6
                  });
                  _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                }
                break;
              }
            case 'source-url':
              {
                if (!currentMessage) break;
                var sourcePart = {
                  type: 'source-url',
                  sourceId: chunk.sourceId,
                  url: chunk.url,
                  title: chunk.title
                };
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: [].concat(_toConsumableArray(currentMessage.parts), [sourcePart])
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'source-document':
              {
                if (!currentMessage) break;
                var docPart = {
                  type: 'source-document',
                  sourceId: chunk.sourceId,
                  mediaType: chunk.mediaType,
                  title: chunk.title,
                  filename: chunk.filename,
                  providerMetadata: chunk.providerMetadata
                };
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: [].concat(_toConsumableArray(currentMessage.parts), [docPart])
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'file':
              {
                if (!currentMessage) break;
                var filePart = {
                  type: 'file',
                  url: chunk.url,
                  mediaType: chunk.mediaType
                };
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: [].concat(_toConsumableArray(currentMessage.parts), [filePart])
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'start-step':
              {
                if (!currentMessage) break;
                var stepPart = {
                  type: 'step-start'
                };
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  parts: [].concat(_toConsumableArray(currentMessage.parts), [stepPart])
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'message-metadata':
              {
                if (!currentMessage) break;
                currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                  metadata: chunk.messageMetadata
                });
                _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                break;
              }
            case 'error':
              {
                isError = true;
                throw new Error(chunk.errorText);
              }
            case 'abort':
              {
                isAbort = true;
                break;
              }
            case 'finish':
              {
                if (currentMessage && chunk.messageMetadata !== undefined) {
                  currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                    metadata: chunk.messageMetadata
                  });
                  _this3.state.replaceMessage(currentMessageIndex, currentMessage);
                }
                break;
              }
            default:
              {
                // Handle data parts (data-*)
                var chunkType = chunk.type;
                if (chunkType !== null && chunkType !== void 0 && chunkType.startsWith('data-') && currentMessage) {
                  var dataPart = {
                    type: chunkType,
                    id: chunk.id,
                    data: chunk.data
                  };
                  currentMessage = _objectSpread(_objectSpread({}, currentMessage), {}, {
                    parts: [].concat(_toConsumableArray(currentMessage.parts), [dataPart])
                  });
                  _this3.state.replaceMessage(currentMessageIndex, currentMessage);

                  // Trigger onData callback
                  if (_this3.onData) {
                    _this3.onData(dataPart);
                  }
                }
              }
          }
        }, function () {
          // Wait for any pending tool calls to complete
          pendingToolCall.then(function () {
            // Stream finished successfully
            _this3.setStatus({
              status: 'ready'
            });
            _this3.activeResponse = null;

            // Trigger onFinish callback
            if (_this3.onFinish && currentMessage) {
              _this3.onFinish({
                message: currentMessage,
                messages: _this3.state.messages,
                isAbort: isAbort,
                isDisconnect: isDisconnect,
                isError: isError
              });
            }

            // Note: sendAutomaticallyWhen is only checked in addToolResult,
            // not here. For server-executed tools, the server continues the
            // conversation. For client-executed tools, addToolResult handles it.
            resolve();
          });
        }, function (error) {
          if (error.name === 'AbortError') {
            isAbort = true;
            _this3.setStatus({
              status: 'ready'
            });
          } else {
            isDisconnect = true;
            _this3.handleError(error);
          }

          // Still call onFinish even on error/abort
          if (_this3.onFinish && currentMessage) {
            _this3.onFinish({
              message: currentMessage,
              messages: _this3.state.messages,
              isAbort: isAbort,
              isDisconnect: isDisconnect,
              isError: isError
            });
          }
          resolve();
        });
      });
    }
  }, {
    key: "handleError",
    value: function handleError(error) {
      this.setStatus({
        status: 'error',
        error: error
      });
      if (this.onError) {
        this.onError(error);
      }
    }
  }, {
    key: "convertFilesToParts",
    value: function convertFilesToParts(files) {
      var _this4 = this;
      if (Array.isArray(files)) {
        return Promise.resolve(files);
      }
      var promises = [];
      var _loop = function _loop() {
        var file = files[i];
        promises.push(_this4.fileToDataUrl(file).then(function (dataUrl) {
          return {
            type: 'file',
            mediaType: file.type,
            filename: file.name,
            url: dataUrl
          };
        }));
      };
      for (var i = 0; i < files.length; i++) {
        _loop();
      }
      return Promise.all(promises);
    }
  }, {
    key: "fileToDataUrl",
    value: function fileToDataUrl(file) {
      return new Promise(function (resolve, reject) {
        var reader = new FileReader();
        reader.onload = function () {
          return resolve(reader.result);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
  }]);
  return AbstractChat;
}();