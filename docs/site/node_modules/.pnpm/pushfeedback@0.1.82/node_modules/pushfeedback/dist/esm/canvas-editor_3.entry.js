import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-f65e9124.js';

const canvasEditorCss = ":host{display:block}.canvas-editor-wrapper{position:relative}.canvas-editor-overlay{position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.8);display:flex;align-items:center;justify-content:center;z-index:9999}.canvas-editor-modal{width:95vw;height:95vh;max-width:none;max-height:none;background:var(--feedback-canvas-editor-bg-color, #ffffff);border-radius:12px;border:1px solid rgba(0, 0, 0, 0.08);display:flex;flex-direction:column;overflow:hidden;box-shadow:0 0 0 1px rgba(0, 0, 0, 0.02),\n    0 8px 16px rgba(0, 0, 0, 0.08),\n    0 16px 32px rgba(0, 0, 0, 0.08),\n    0 32px 64px rgba(0, 0, 0, 0.06)}.canvas-editor-header{background:var(--feedback-canvas-editor-header-bg-color, #fafafa);border-bottom:1px solid rgba(0, 0, 0, 0.06);padding:16px 20px;display:flex;flex-direction:column;gap:16px}.canvas-editor-title h3{margin:0;font-size:18px;font-weight:600;color:var(--feedback-canvas-editor-tool-text-color, #1a1a1a);letter-spacing:-0.02em}.canvas-editor-toolbar{display:flex;flex-wrap:wrap;align-items:center;gap:16px}.toolbar-section{display:flex;align-items:center;gap:8px}.tool-group{display:flex;align-items:center;gap:4px}.tool-btn{width:36px;height:36px;display:flex;align-items:center;justify-content:center;background:var(--feedback-canvas-editor-tool-bg-color, #ffffff);border:1.5px solid rgba(0, 0, 0, 0.08);border-radius:8px;cursor:pointer;transition:all 0.2s cubic-bezier(0.4, 0, 0.2, 1);padding:0;box-shadow:0 1px 2px rgba(0, 0, 0, 0.04)}.tool-btn svg{width:18px;height:18px;color:var(--feedback-canvas-editor-tool-text-color, #333)}.tool-btn:hover:not(:disabled){background:var(--feedback-canvas-editor-tool-bg-hover, #f5f5f5);border-color:rgba(0, 0, 0, 0.12);transform:translateY(-1px);box-shadow:0 2px 4px rgba(0, 0, 0, 0.08)}.tool-btn.active,.tool-btn.active:hover{background:var(--feedback-canvas-editor-tool-bg-active, #0070f4);color:var(--feedback-canvas-editor-tool-text-active, #ffffff);border-color:var(--feedback-canvas-editor-tool-bg-active, #0070f4);box-shadow:0 2px 8px rgba(0, 112, 244, 0.3)}.tool-btn.active svg{color:var(--feedback-canvas-editor-tool-text-active, #ffffff)}.tool-btn:disabled{opacity:0.4;cursor:not-allowed;color:var(--feedback-canvas-editor-tool-text-color, #333)}.toolbar-divider{width:1px;height:24px;background:var(--feedback-canvas-editor-divider-color, #e0e0e0);margin:0 4px}.undo-btn,.delete-btn{background:var(--feedback-canvas-editor-tool-bg-color, #ffffff) !important;border:1px solid var(--feedback-canvas-editor-border-color, #e0e0e0) !important}.undo-btn:hover:not(:disabled),.delete-btn:hover:not(:disabled){background:var(--feedback-canvas-editor-tool-bg-hover, #f0f0f0) !important}.undo-btn:disabled,.delete-btn:disabled{opacity:0.3;cursor:not-allowed}.delete-btn:hover:not(:disabled){background:#fee !important;border-color:#fcc !important}.delete-btn:hover:not(:disabled) svg{color:#c53030}.color-palette{display:flex;align-items:center;gap:6px}.color-slot-wrapper{position:relative;display:flex;align-items:center}.color-btn{width:32px;height:32px;border-radius:8px;border:2px solid transparent;cursor:pointer;transition:all 0.2s cubic-bezier(0.4, 0, 0.2, 1);display:flex;align-items:center;justify-content:center;background:var(--feedback-canvas-editor-tool-bg-color, #ffffff);border:2px solid rgba(0, 0, 0, 0.08);box-shadow:0 1px 2px rgba(0, 0, 0, 0.04)}.color-btn:hover{transform:translateY(-2px) scale(1.05);box-shadow:0 4px 8px rgba(0, 0, 0, 0.12)}.color-btn.active{border-color:var(--feedback-primary-color, #0070f4);box-shadow:0 0 0 2px rgba(0, 112, 244, 0.2)}.color-btn.editing{border-color:var(--feedback-primary-color, #0070f4)}.color-picker-dropdown{position:absolute;top:100%;left:0;z-index:1000;margin-top:4px;background:var(--feedback-canvas-editor-tool-bg-color, #ffffff);border:1px solid var(--feedback-canvas-editor-border-color, #e0e0e0);border-radius:6px;padding:8px;box-shadow:0 4px 12px rgba(0, 0, 0, 0.1)}.color-picker-dropdown input[type=\"color\"]{width:40px;height:40px;border:none;border-radius:4px;cursor:pointer}.size-control{display:flex;align-items:center;gap:8px;background:var(--feedback-canvas-editor-tool-bg-color, #ffffff);border:1px solid var(--feedback-canvas-editor-border-color, #e0e0e0);border-radius:6px;padding:6px 12px}.size-slider{width:80px;height:14px;-webkit-appearance:none;appearance:none;background:transparent;border-radius:2px;outline:none;cursor:pointer;border:none;position:relative}.size-slider::before{content:'';position:absolute;top:50%;left:0;right:0;height:4px;background:rgba(0, 0, 0, 0.15);border-radius:2px;transform:translateY(-50%);pointer-events:none}.size-slider::-webkit-slider-track{width:100%;height:4px;background:transparent;border-radius:2px;border:none}.size-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:14px;height:14px;background:var(--feedback-primary-color, #0070f4);border-radius:50%;cursor:pointer;position:relative;z-index:1}.size-slider::-moz-range-track{width:100%;height:4px;background:transparent;border-radius:2px;border:none}.size-slider::-moz-range-thumb{width:14px;height:14px;background:var(--feedback-primary-color, #0070f4);border-radius:50%;border:none;cursor:pointer}.size-slider::-ms-track{width:100%;height:4px;background:transparent;border-radius:2px;border:none;color:transparent}.size-slider::-ms-thumb{width:14px;height:14px;background:var(--feedback-primary-color, #0070f4);border-radius:50%;border:none;cursor:pointer}.size-value{font-weight:500;color:var(--feedback-canvas-editor-tool-text-color, #333);font-size:12px;min-width:30px}.selected-annotation-controls{border-left:2px solid var(--feedback-canvas-editor-divider-color, #e0e0e0);padding-left:12px;margin-left:8px;min-width:200px}.text-controls{display:flex;flex-direction:row;align-items:center;gap:12px}.font-size-control,.border-width-control{display:flex;align-items:center;gap:6px}.font-size-control label,.border-width-control label{font-size:12px;color:var(--feedback-canvas-editor-tool-text-color, #333);font-weight:500;min-width:35px}.action-btn{display:flex;align-items:center;gap:8px;padding:0 20px;border:1.5px solid rgba(0, 0, 0, 0.08);border-radius:8px;cursor:pointer;font-size:14px;font-weight:500;transition:all 0.2s cubic-bezier(0.4, 0, 0.2, 1);min-width:80px;justify-content:center;height:40px;box-shadow:0 1px 2px rgba(0, 0, 0, 0.04)}.action-btn.secondary{background:var(--feedback-canvas-editor-tool-bg-color, #ffffff);color:var(--feedback-canvas-editor-tool-text-color, #333);border-color:rgba(0, 0, 0, 0.08)}.action-btn.secondary:hover{background:var(--feedback-canvas-editor-tool-bg-hover, #f5f5f5);border-color:rgba(0, 0, 0, 0.12);transform:translateY(-1px);box-shadow:0 4px 8px rgba(0, 0, 0, 0.08)}.action-btn.primary{background:var(--feedback-primary-color, #0070f4);color:#ffffff;border-color:var(--feedback-primary-color, #0070f4);box-shadow:0 2px 4px rgba(0, 112, 244, 0.2)}.action-btn.primary:hover{background:#0056cc;border-color:#0056cc;transform:translateY(-1px);box-shadow:0 6px 12px rgba(0, 112, 244, 0.3)}.action-btn:active{transform:translateY(0)}.action-btn.small{height:28px;padding:4px 8px;font-size:12px;min-width:65px}.shape-controls{display:flex;flex-direction:column;gap:8px}.canvas-editor-content{flex:1;display:flex;align-items:center;justify-content:center;padding:24px;background:var(--feedback-canvas-editor-content-bg, #f5f5f5);overflow:hidden;min-height:0;min-width:0;position:relative}.canvas-editor-content::-webkit-scrollbar{width:8px;height:8px}.canvas-editor-content::-webkit-scrollbar-track{background:transparent}.canvas-editor-content::-webkit-scrollbar-thumb{background:rgba(0, 0, 0, 0.2);border-radius:4px}.canvas-editor-content::-webkit-scrollbar-thumb:hover{background:rgba(0, 0, 0, 0.3)}.annotation-canvas{max-width:calc(100% - 48px);max-height:calc(100% - 48px);width:auto !important;height:auto !important;cursor:crosshair;border-radius:8px;box-shadow:0 0 0 1px rgba(0, 0, 0, 0.04),\n    0 4px 6px rgba(0, 0, 0, 0.06),\n    0 8px 16px rgba(0, 0, 0, 0.08);background:#ffffff;transition:box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);object-fit:contain;display:block;margin:auto}.annotation-canvas:hover{box-shadow:0 0 0 1px rgba(0, 0, 0, 0.06),\n    0 6px 10px rgba(0, 0, 0, 0.08),\n    0 12px 24px rgba(0, 0, 0, 0.1)}@media screen and (min-width: 1920px){.canvas-editor-modal{width:90vw;height:90vh}.canvas-editor-content{padding:32px}}@media screen and (min-width: 1200px) and (max-width: 1919px){.canvas-editor-modal{width:92vw;height:92vh}.canvas-editor-content{padding:28px}}@media screen and (min-width: 769px) and (max-width: 1199px){.canvas-editor-modal{width:95vw;height:95vh}}@media screen and (max-width: 768px){.canvas-editor-modal{width:100vw;height:100vh;border-radius:0}.canvas-editor-toolbar{flex-direction:column;align-items:stretch;gap:8px}.toolbar-section{justify-content:center}.selected-annotation-controls{border-left:none;border-top:2px solid var(--feedback-canvas-editor-divider-color, #e0e0e0);padding-left:0;padding-top:8px;margin-left:0;margin-top:8px;min-width:auto}.canvas-editor-content{padding:16px}}";

const CanvasEditor = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.screenshotReady = createEvent(this, "screenshotReady", 7);
    this.screenshotCancelled = createEvent(this, "screenshotCancelled", 7);
    this.screenshotFailed = createEvent(this, "screenshotFailed", 7);
    this.handleWindowResize = () => {
      // Debounce resize events
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }
      this.resizeTimeout = setTimeout(() => {
        if (this.showCanvasEditor && this.originalImageData) {
          this.initializeCanvas();
        }
      }, 250);
    };
    this.openScreenShot = async () => {
      // Show loading state immediately
      this.takingScreenshot = true;
      // Clear any previous annotations when taking a new screenshot
      this.annotations = [];
      this.currentAnnotation = null;
      this.isDrawing = false;
      this.hoveredAnnotation = null;
      // Hide any feedback buttons on the page
      this.hideAllFeedbackElements();
      try {
        // Wait a moment for UI to update before capturing
        await new Promise(resolve => setTimeout(resolve, 100));
        // Capture viewport screenshot using browser API
        const dataUrl = await this.captureViewportScreenshot();
        this.originalImageData = dataUrl;
        // Reset loading state
        this.takingScreenshot = false;
        // Go directly to canvas editor
        this.showCanvasEditor = true;
        // Restore feedback elements visibility
        this.showAllFeedbackElements();
        // Initialize canvas after a short delay to ensure DOM is ready
        setTimeout(() => {
          this.initializeCanvas();
        }, 100);
      }
      catch (error) {
        console.error('Failed to capture screenshot:', error);
        // Reset loading state on error
        this.takingScreenshot = false;
        // Restore feedback elements on error
        this.showAllFeedbackElements();
        // Show error message to user
        this.handleScreenshotError(error);
      }
    };
    this.hideAllFeedbackElements = () => {
      // Hide all feedback buttons and modals on the page
      const feedbackElements = document.querySelectorAll('feedback-button, feedback-modal');
      feedbackElements.forEach(element => {
        element.style.visibility = 'hidden';
      });
    };
    this.showAllFeedbackElements = () => {
      // Show all feedback buttons and modals on the page
      const feedbackElements = document.querySelectorAll('feedback-button, feedback-modal');
      feedbackElements.forEach(element => {
        element.style.visibility = 'visible';
      });
    };
    this.handleScreenshotError = (error) => {
      let errorMessage = this.screenshotErrorGeneral;
      if (error.name === 'NotAllowedError') {
        errorMessage += ' ' + this.screenshotErrorPermission;
      }
      else if (error.name === 'NotSupportedError') {
        errorMessage += ' ' + this.screenshotErrorNotSupported;
      }
      else if (error.name === 'NotFoundError') {
        errorMessage += ' ' + this.screenshotErrorNotFound;
      }
      else if (error.name === 'AbortError') {
        errorMessage += ' ' + this.screenshotErrorCancelled;
      }
      else if (error.message && error.message.includes('not supported')) {
        errorMessage += ' ' + this.screenshotErrorBrowserNotSupported;
      }
      else {
        errorMessage += ' ' + this.screenshotErrorUnexpected;
      }
      // Just emit the error to parent - don't show internal notification
      this.screenshotFailed.emit({ error: errorMessage });
    };
    this.closeCanvasEditor = () => {
      this.showCanvasEditor = false;
      this.screenshotCancelled.emit();
    };
    this.saveAnnotations = () => {
      if (this.canvasRef) {
        // Create final image with annotations
        const finalDataUrl = this.canvasRef.toDataURL('image/png');
        this.screenshotReady.emit({ screenshot: finalDataUrl });
      }
      this.showCanvasEditor = false;
    };
    this.initializeCanvas = () => {
      if (!this.canvasRef || !this.originalImageData)
        return;
      this.canvasContext = this.canvasRef.getContext('2d');
      const img = new Image();
      img.onload = () => {
        // Set canvas to original image dimensions
        this.canvasRef.width = img.width;
        this.canvasRef.height = img.height;
        // Get available container dimensions with more generous padding
        const containerWidth = this.canvasRef.parentElement.clientWidth - 48;
        const containerHeight = this.canvasRef.parentElement.clientHeight - 48;
        // Calculate scale factors for both dimensions
        const scaleX = containerWidth / img.width;
        const scaleY = containerHeight / img.height;
        // Use a more aggressive scaling approach for large screens
        // Allow scaling up to 1.5x on very large screens, but still maintain aspect ratio
        const maxScale = window.innerWidth > 1920 ? 1.5 : (window.innerWidth > 1200 ? 1.2 : 1);
        const scale = Math.min(scaleX, scaleY, maxScale);
        // Calculate final display dimensions
        const displayWidth = img.width * scale;
        const displayHeight = img.height * scale;
        // Set CSS size for display
        this.canvasRef.style.width = `${displayWidth}px`;
        this.canvasRef.style.height = `${displayHeight}px`;
        // Draw the original image at full resolution
        this.canvasContext.drawImage(img, 0, 0);
        // Redraw existing annotations
        this.redrawAnnotations();
      };
      img.src = this.originalImageData;
    };
    this.redrawAnnotations = () => {
      if (!this.canvasContext)
        return;
      // Clear and redraw background image
      const img = new Image();
      img.onload = () => {
        this.canvasContext.clearRect(0, 0, this.canvasRef.width, this.canvasRef.height);
        this.canvasContext.drawImage(img, 0, 0);
        // Draw all annotations
        this.annotations.forEach(annotation => {
          this.drawAnnotation(annotation);
        });
      };
      img.src = this.originalImageData;
    };
    this.drawAnnotation = (annotation) => {
      if (!this.canvasContext)
        return;
      this.canvasContext.strokeStyle = annotation.color;
      this.canvasContext.lineWidth = annotation.lineWidth;
      this.canvasContext.lineCap = 'round';
      this.canvasContext.lineJoin = 'round';
      switch (annotation.type) {
        case 'rectangle':
          this.canvasContext.strokeRect(annotation.startX, annotation.startY, annotation.width, annotation.height);
          // Draw selection indicator if this annotation is selected
          if (this.selectedAnnotation === annotation) {
            this.drawSelectionIndicator(annotation);
          }
          // Draw resize handles if this annotation is hovered
          if (this.hoveredAnnotation === annotation) {
            this.drawRectangleResizeHandles(annotation);
          }
          break;
        case 'line':
          this.canvasContext.beginPath();
          this.canvasContext.moveTo(annotation.startX, annotation.startY);
          this.canvasContext.lineTo(annotation.endX, annotation.endY);
          this.canvasContext.stroke();
          // Draw selection indicator if this annotation is selected
          if (this.selectedAnnotation === annotation) {
            this.drawSelectionIndicator(annotation);
          }
          // Draw resize handles if this annotation is hovered
          if (this.hoveredAnnotation === annotation) {
            this.drawLineResizeHandles(annotation);
          }
          break;
        case 'arrow':
          this.drawArrow(annotation.startX, annotation.startY, annotation.endX, annotation.endY);
          // Draw selection indicator if this annotation is selected
          if (this.selectedAnnotation === annotation) {
            this.drawSelectionIndicator(annotation);
          }
          // Draw resize handles if this annotation is hovered
          if (this.hoveredAnnotation === annotation) {
            this.drawLineResizeHandles(annotation);
          }
          break;
        case 'text':
          const fontSize = annotation.fontSize || 24;
          this.canvasContext.fillStyle = annotation.color;
          this.canvasContext.font = `${fontSize}px Arial`;
          this.canvasContext.fillText(annotation.text, annotation.x, annotation.y);
          // Draw selection indicator if this annotation is selected
          if (this.selectedAnnotation === annotation) {
            this.drawTextSelectionIndicator(annotation);
          }
          break;
      }
    };
    // Draw selection indicator for shapes
    this.drawSelectionIndicator = (annotation) => {
      if (!this.canvasContext)
        return;
      // Save current context
      const originalStrokeStyle = this.canvasContext.strokeStyle;
      const originalLineWidth = this.canvasContext.lineWidth;
      // Draw selection outline
      this.canvasContext.strokeStyle = '#0070F4';
      this.canvasContext.lineWidth = 2;
      this.canvasContext.setLineDash([5, 5]);
      switch (annotation.type) {
        case 'rectangle':
          this.canvasContext.strokeRect(annotation.startX - 2, annotation.startY - 2, annotation.width + 4, annotation.height + 4);
          break;
        case 'line':
        case 'arrow':
          this.canvasContext.beginPath();
          this.canvasContext.moveTo(annotation.startX, annotation.startY);
          this.canvasContext.lineTo(annotation.endX, annotation.endY);
          this.canvasContext.stroke();
          break;
      }
      // Restore context
      this.canvasContext.setLineDash([]);
      this.canvasContext.strokeStyle = originalStrokeStyle;
      this.canvasContext.lineWidth = originalLineWidth;
    };
    // Draw selection indicator for text
    this.drawTextSelectionIndicator = (annotation) => {
      if (!this.canvasContext)
        return;
      const fontSize = annotation.fontSize || 24;
      const textWidth = this.getTextWidth(annotation.text, fontSize);
      // Save current context
      const originalStrokeStyle = this.canvasContext.strokeStyle;
      const originalLineWidth = this.canvasContext.lineWidth;
      // Draw selection outline around text
      this.canvasContext.strokeStyle = '#0070F4';
      this.canvasContext.lineWidth = 2;
      this.canvasContext.setLineDash([3, 3]);
      this.canvasContext.strokeRect(annotation.x - 4, annotation.y - fontSize - 4, textWidth + 8, fontSize + 8);
      // Restore context
      this.canvasContext.setLineDash([]);
      this.canvasContext.strokeStyle = originalStrokeStyle;
      this.canvasContext.lineWidth = originalLineWidth;
    };
    this.drawArrow = (fromX, fromY, toX, toY) => {
      const headlen = 15; // Arrow head length
      const angle = Math.atan2(toY - fromY, toX - fromX);
      // Draw line
      this.canvasContext.beginPath();
      this.canvasContext.moveTo(fromX, fromY);
      this.canvasContext.lineTo(toX, toY);
      this.canvasContext.stroke();
      // Draw arrow head
      this.canvasContext.beginPath();
      this.canvasContext.moveTo(toX, toY);
      this.canvasContext.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
      this.canvasContext.moveTo(toX, toY);
      this.canvasContext.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
      this.canvasContext.stroke();
    };
    this.undoLastAnnotation = () => {
      this.annotations = this.annotations.slice(0, -1);
      this.redrawAnnotations();
    };
    this.deleteSelectedAnnotation = () => {
      if (this.selectedAnnotation) {
        const index = this.annotations.findIndex(a => a === this.selectedAnnotation);
        if (index !== -1) {
          this.annotations = this.annotations.filter((_, i) => i !== index);
          this.selectedAnnotation = null;
          this.redrawAnnotations();
        }
      }
    };
    // Handle color slot editing
    this.handleColorSlotClick = (colorIndex) => {
      if (this.editingColorIndex === colorIndex) {
        // If already editing this slot, just select the color
        this.canvasDrawingColor = this.defaultColors[colorIndex];
        this.showColorPicker = false;
        this.editingColorIndex = -1;
      }
      else {
        // Start editing this color slot
        this.editingColorIndex = colorIndex;
        this.showColorPicker = true;
        this.canvasDrawingColor = this.defaultColors[colorIndex];
      }
    };
    // Update color in slot
    this.updateColorSlot = (newColor) => {
      if (this.editingColorIndex >= 0 && this.editingColorIndex < this.defaultColors.length) {
        this.defaultColors[this.editingColorIndex] = newColor;
        this.canvasDrawingColor = newColor;
        this.showColorPicker = false;
        this.editingColorIndex = -1;
        // Force reactivity
        this.defaultColors = [...this.defaultColors];
      }
    };
    // Handle color picker input without closing
    this.handleColorPickerInput = (event) => {
      event.stopPropagation();
      const newColor = event.target.value;
      if (this.editingColorIndex >= 0 && this.editingColorIndex < this.defaultColors.length) {
        this.defaultColors[this.editingColorIndex] = newColor;
        this.canvasDrawingColor = newColor;
        // Force reactivity
        this.defaultColors = [...this.defaultColors];
      }
    };
    // Handle color picker click to prevent closing
    this.handleColorPickerClick = (event) => {
      event.stopPropagation();
    };
    // Close color picker
    this.closeColorPicker = () => {
      this.showColorPicker = false;
      this.editingColorIndex = -1;
    };
    // Get text width for resize handle positioning
    this.getTextWidth = (text, fontSize) => {
      // Better text width calculation
      if (!this.canvasContext) {
        return text.length * fontSize * 0.6; // Fallback
      }
      // Use actual canvas measurement for accuracy
      const originalFont = this.canvasContext.font;
      this.canvasContext.font = `${fontSize}px Arial`;
      const width = this.canvasContext.measureText(text).width;
      this.canvasContext.font = originalFont;
      return width;
    };
    // Check if point is in resize handle for shapes (not text)
    this.isPointInResizeHandle = (x, y, annotation) => {
      const handleSize = 8;
      switch (annotation.type) {
        case 'rectangle':
          const right = annotation.startX + annotation.width;
          const bottom = annotation.startY + annotation.height;
          // Only check bottom-right corner handle
          return x >= right - handleSize / 2 && x <= right + handleSize / 2 &&
            y >= bottom - handleSize / 2 && y <= bottom + handleSize / 2;
        case 'line':
        case 'arrow':
          // Check both endpoint handles
          const lineHandles = [
            { x: annotation.startX, y: annotation.startY, point: 'start' },
            { x: annotation.endX, y: annotation.endY, point: 'end' }
          ];
          for (const handle of lineHandles) {
            if (x >= handle.x - handleSize / 2 && x <= handle.x + handleSize / 2 &&
              y >= handle.y - handleSize / 2 && y <= handle.y + handleSize / 2) {
              return handle.point; // Return which endpoint was clicked
            }
          }
          return false;
        default:
          return false;
      }
    };
    // Draw resize handles for rectangle annotation (only bottom-right corner)
    this.drawRectangleResizeHandles = (annotation) => {
      if (!this.canvasContext || annotation.type !== 'rectangle')
        return;
      const handleSize = 8;
      const right = annotation.startX + annotation.width;
      const bottom = annotation.startY + annotation.height;
      // Only draw bottom-right corner handle
      const handle = { x: right, y: bottom };
      // Draw the handle
      this.canvasContext.fillStyle = '#0070F4'; // Primary color
      this.canvasContext.strokeStyle = '#ffffff';
      this.canvasContext.lineWidth = 2;
      this.canvasContext.fillRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
      this.canvasContext.strokeRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
    };
    // Draw resize handles for line/arrow annotation
    this.drawLineResizeHandles = (annotation) => {
      if (!this.canvasContext || (annotation.type !== 'line' && annotation.type !== 'arrow'))
        return;
      const handleSize = 8;
      // Define handle positions (2 endpoints)
      const handles = [
        { x: annotation.startX, y: annotation.startY },
        { x: annotation.endX, y: annotation.endY } // End point
      ];
      // Draw each handle
      this.canvasContext.fillStyle = '#0070F4'; // Primary color
      this.canvasContext.strokeStyle = '#ffffff';
      this.canvasContext.lineWidth = 2;
      handles.forEach(handle => {
        this.canvasContext.fillRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
        this.canvasContext.strokeRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
      });
    };
    // Start resize for shapes
    this.startResize = (annotation, handle, startPos) => {
      this.isResizing = true;
      this.resizingAnnotation = annotation;
      this.resizeHandle = handle;
      this.dragStartPos = startPos;
      // Store original values for different annotation types
      if (annotation.type === 'rectangle') {
        this.resizeStartDimensions = { width: annotation.width, height: annotation.height };
      }
    };
    // Handle resize for different annotation types
    this.handleResize = (currentPos) => {
      if (!this.resizingAnnotation || !this.dragStartPos)
        return;
      const annotation = this.resizingAnnotation;
      const index = this.annotations.findIndex(a => a === annotation);
      if (index === -1)
        return;
      let updatedAnnotation = Object.assign({}, annotation);
      switch (annotation.type) {
        case 'rectangle':
          // Rectangle resize logic - only bottom-right corner
          const rectDeltaX = currentPos.x - this.dragStartPos.x;
          const rectDeltaY = currentPos.y - this.dragStartPos.y;
          // Update width and height based on original dimensions plus delta
          updatedAnnotation.width = Math.max(10, this.resizeStartDimensions.width + rectDeltaX);
          updatedAnnotation.height = Math.max(10, this.resizeStartDimensions.height + rectDeltaY);
          break;
        case 'line':
        case 'arrow':
          // Line/arrow resize logic - move endpoints
          if (this.resizeHandle === 'start') {
            updatedAnnotation.startX = currentPos.x;
            updatedAnnotation.startY = currentPos.y;
          }
          else if (this.resizeHandle === 'end') {
            updatedAnnotation.endX = currentPos.x;
            updatedAnnotation.endY = currentPos.y;
          }
          break;
      }
      // Update annotation in array
      this.annotations[index] = updatedAnnotation;
      this.resizingAnnotation = updatedAnnotation;
      this.redrawAnnotations();
    };
    // Text editing methods
    this.startTextEditing = (annotation) => {
      const newText = prompt(this.editTextPromptText, annotation.text);
      if (newText !== null && newText.trim()) {
        const index = this.annotations.findIndex(a => a === annotation);
        if (index !== -1) {
          this.annotations[index] = Object.assign(Object.assign({}, annotation), { text: newText.trim() });
          this.selectedAnnotation = this.annotations[index];
          this.redrawAnnotations();
        }
      }
    };
    // Update selected annotation font size
    this.updateSelectedTextSize = (newSize) => {
      if (this.selectedAnnotation && this.selectedAnnotation.type === 'text') {
        const index = this.annotations.findIndex(a => a === this.selectedAnnotation);
        if (index !== -1) {
          this.annotations[index] = Object.assign(Object.assign({}, this.selectedAnnotation), { fontSize: Math.max(8, Math.min(72, newSize)) });
          this.selectedAnnotation = this.annotations[index];
          this.redrawAnnotations();
        }
      }
    };
    // Update selected annotation border width
    this.updateSelectedBorderWidth = (newWidth) => {
      if (this.selectedAnnotation && ['rectangle', 'line', 'arrow'].includes(this.selectedAnnotation.type)) {
        const index = this.annotations.findIndex(a => a === this.selectedAnnotation);
        if (index !== -1) {
          this.annotations[index] = Object.assign(Object.assign({}, this.selectedAnnotation), { lineWidth: Math.max(1, Math.min(20, newWidth)) });
          this.selectedAnnotation = this.annotations[index];
          this.redrawAnnotations();
        }
      }
    };
    // Enhanced mouse down handler with resize support
    this.handleCanvasMouseDown = (event) => {
      if (!this.canvasRef)
        return;
      // Disable drawing on mobile devices
      if (window.innerWidth <= 768)
        return;
      // Close color picker if open
      if (this.showColorPicker) {
        this.closeColorPicker();
      }
      const coords = this.getCanvasCoordinates(event);
      // Check if clicking on existing annotation first
      const found = this.findAnnotationAt(coords.x, coords.y);
      if (found) {
        // Select the annotation
        this.selectedAnnotation = found.annotation;
        // Check if clicking on resize handle for shapes (not text)
        if (found.annotation.type !== 'text') {
          const handle = this.isPointInResizeHandle(coords.x, coords.y, found.annotation);
          if (handle) {
            this.startResize(found.annotation, handle, coords);
            this.canvasRef.style.cursor = 'nw-resize';
            return;
          }
        }
        // Check for double-click to edit text
        if (found.annotation.type === 'text' && event.detail === 2) {
          this.startTextEditing(found.annotation);
          return;
        }
        // Start dragging existing annotation
        if (!this.isDrawing) {
          this.isDragging = true;
          this.draggedAnnotation = found.annotation;
          this.dragStartPos = coords;
          this.canvasRef.style.cursor = 'grabbing';
          return;
        }
      }
      else {
        // Clear selection if clicking on empty space
        this.selectedAnnotation = null;
      }
      // Original drawing logic
      this.isDrawing = true;
      if (this.canvasDrawingTool === 'text') {
        const text = prompt(this.editTextPromptText);
        if (text) {
          const annotation = {
            type: 'text',
            x: coords.x,
            y: coords.y,
            text,
            color: this.canvasDrawingColor,
            fontSize: this.canvasTextSize
          };
          this.annotations = [...this.annotations, annotation];
          this.redrawAnnotations();
        }
        this.isDrawing = false;
      }
      else {
        this.currentAnnotation = {
          type: this.canvasDrawingTool,
          startX: coords.x,
          startY: coords.y,
          color: this.canvasDrawingColor,
          lineWidth: this.canvasLineWidth
        };
      }
    };
    this.handleCanvasMouseMove = (event) => {
      if (!this.canvasRef)
        return;
      // Disable drawing on mobile devices
      if (window.innerWidth <= 768)
        return;
      const coords = this.getCanvasCoordinates(event);
      // Handle resizing for shapes
      if (this.isResizing && this.resizingAnnotation) {
        this.handleResize(coords);
        return;
      }
      // Handle dragging existing annotation
      if (this.isDragging && this.draggedAnnotation && this.dragStartPos) {
        const deltaX = coords.x - this.dragStartPos.x;
        const deltaY = coords.y - this.dragStartPos.y;
        // Update annotation position
        const updatedAnnotation = Object.assign({}, this.draggedAnnotation);
        switch (updatedAnnotation.type) {
          case 'rectangle':
            updatedAnnotation.startX += deltaX;
            updatedAnnotation.startY += deltaY;
            break;
          case 'line':
          case 'arrow':
            updatedAnnotation.startX += deltaX;
            updatedAnnotation.startY += deltaY;
            updatedAnnotation.endX += deltaX;
            updatedAnnotation.endY += deltaY;
            break;
          case 'text':
            updatedAnnotation.x += deltaX;
            updatedAnnotation.y += deltaY;
            break;
        }
        // Update annotation in array
        const index = this.annotations.findIndex(a => a === this.draggedAnnotation);
        if (index !== -1) {
          this.annotations[index] = updatedAnnotation;
          this.draggedAnnotation = updatedAnnotation;
        }
        this.dragStartPos = coords;
        this.redrawAnnotations();
        return;
      }
      // Handle drawing new annotation
      if (this.isDrawing && this.currentAnnotation) {
        if (this.canvasDrawingTool === 'rectangle') {
          this.currentAnnotation.width = coords.x - this.currentAnnotation.startX;
          this.currentAnnotation.height = coords.y - this.currentAnnotation.startY;
        }
        else {
          this.currentAnnotation.endX = coords.x;
          this.currentAnnotation.endY = coords.y;
        }
        this.redrawAnnotations();
        this.drawAnnotation(this.currentAnnotation);
        return;
      }
      // Handle hover states and cursor changes
      const found = this.findAnnotationAt(coords.x, coords.y);
      if (found) {
        // Check if hovering over resize handle for shapes (not text)
        if (found.annotation.type !== 'text') {
          const handle = this.isPointInResizeHandle(coords.x, coords.y, found.annotation);
          if (handle) {
            this.canvasRef.style.cursor = 'nw-resize';
            this.hoveredAnnotation = found.annotation;
            this.redrawAnnotations();
            return;
          }
        }
        // Regular hover over annotation
        this.canvasRef.style.cursor = 'grab';
        if (this.hoveredAnnotation !== found.annotation) {
          this.hoveredAnnotation = found.annotation;
          this.redrawAnnotations();
        }
      }
      else {
        // No annotation under cursor
        this.canvasRef.style.cursor = 'crosshair';
        if (this.hoveredAnnotation) {
          this.hoveredAnnotation = null;
          this.redrawAnnotations();
        }
      }
    };
    this.handleCanvasMouseUp = () => {
      // Disable drawing on mobile devices
      if (window.innerWidth <= 768)
        return;
      // Handle end of resizing
      if (this.isResizing) {
        this.isResizing = false;
        this.resizingAnnotation = null;
        this.dragStartPos = null;
        this.resizeHandle = false;
        this.resizeStartDimensions = null;
        if (this.canvasRef) {
          this.canvasRef.style.cursor = 'crosshair';
        }
        return;
      }
      // Handle end of dragging
      if (this.isDragging) {
        this.isDragging = false;
        this.draggedAnnotation = null;
        this.dragStartPos = null;
        if (this.canvasRef) {
          this.canvasRef.style.cursor = 'crosshair';
        }
        return;
      }
      // Handle end of drawing
      if (!this.isDrawing || !this.currentAnnotation)
        return;
      this.isDrawing = false;
      this.annotations = [...this.annotations, this.currentAnnotation];
      this.currentAnnotation = null;
      this.redrawAnnotations();
    };
    // Convert screen coordinates to canvas coordinates
    this.getCanvasCoordinates = (event) => {
      if (!this.canvasRef)
        return { x: 0, y: 0 };
      const rect = this.canvasRef.getBoundingClientRect();
      // Calculate the scale factor between display size and actual canvas size
      const scaleX = this.canvasRef.width / rect.width;
      const scaleY = this.canvasRef.height / rect.height;
      const x = (event.clientX - rect.left) * scaleX;
      const y = (event.clientY - rect.top) * scaleY;
      return { x, y };
    };
    // Find annotation under mouse cursor
    this.findAnnotationAt = (x, y) => {
      // Check in reverse order (top to bottom)
      for (let i = this.annotations.length - 1; i >= 0; i--) {
        const annotation = this.annotations[i];
        if (this.isPointInAnnotation(x, y, annotation)) {
          return { annotation, index: i };
        }
      }
      return null;
    };
    // Check if point is within annotation bounds
    this.isPointInAnnotation = (x, y, annotation) => {
      const tolerance = 10; // Click tolerance
      switch (annotation.type) {
        case 'rectangle':
          const left = Math.min(annotation.startX, annotation.startX + annotation.width);
          const right = Math.max(annotation.startX, annotation.startX + annotation.width);
          const top = Math.min(annotation.startY, annotation.startY + annotation.height);
          const bottom = Math.max(annotation.startY, annotation.startY + annotation.height);
          return x >= left - tolerance && x <= right + tolerance &&
            y >= top - tolerance && y <= bottom + tolerance;
        case 'line':
        case 'arrow':
          // Distance from point to line
          const A = annotation.endY - annotation.startY;
          const B = annotation.startX - annotation.endX;
          const C = annotation.endX * annotation.startY - annotation.startX * annotation.endY;
          const distance = Math.abs(A * x + B * y + C) / Math.sqrt(A * A + B * B);
          return distance <= tolerance;
        case 'text':
          // Use actual text dimensions for better dragging
          const fontSize = annotation.fontSize || 24;
          const textWidth = this.getTextWidth(annotation.text, fontSize);
          const textHeight = fontSize;
          // Text bounding box (y coordinate is baseline, so subtract font size for top)
          const textLeft = annotation.x - tolerance;
          const textRight = annotation.x + textWidth + tolerance;
          const textTop = annotation.y - textHeight - tolerance;
          const textBottom = annotation.y + tolerance;
          return x >= textLeft && x <= textRight &&
            y >= textTop && y <= textBottom;
        default:
          return false;
      }
    };
    this.canvasEditorTitle = 'Edit screenshot';
    this.canvasEditorCancelText = 'Cancel';
    this.canvasEditorSaveText = 'Save';
    this.screenshotTakingText = 'Taking screenshot...';
    this.screenshotAttachedText = 'Screenshot attached';
    this.screenshotButtonText = 'Add a screenshot';
    this.autoStartScreenshot = false;
    this.existingScreenshot = '';
    this.editTextButtonText = 'Edit Text';
    this.sizeLabelText = 'Size:';
    this.borderLabelText = 'Border:';
    this.editTextPromptText = 'Edit text:';
    this.screenshotErrorGeneral = 'Failed to capture screenshot.';
    this.screenshotErrorPermission = 'Permission denied. Please allow screen sharing to take screenshots.';
    this.screenshotErrorNotSupported = 'Screen capture is not supported in this browser.';
    this.screenshotErrorNotFound = 'No screen sources available for capture.';
    this.screenshotErrorCancelled = 'Screenshot capture was cancelled.';
    this.screenshotErrorBrowserNotSupported = 'Your browser does not support screen capture. Please use a browser like Chrome, Firefox, or Safari on desktop.';
    this.screenshotErrorUnexpected = 'An unexpected error occurred. Please try again.';
    this.takingScreenshot = false;
    this.showCanvasEditor = false;
    this.canvasDrawingTool = 'rectangle';
    this.canvasDrawingColor = '#ff0000';
    this.canvasLineWidth = 3;
    this.canvasTextSize = 24;
    this.isDrawing = false;
    this.annotations = [];
    this.currentAnnotation = null;
    this.isDragging = false;
    this.draggedAnnotation = null;
    this.dragStartPos = null;
    this.showColorPicker = false;
    this.editingColorIndex = -1;
    this.selectedAnnotation = null;
    this.isResizing = false;
    this.resizingAnnotation = null;
    this.resizeStartSize = 24;
    this.resizeStartDimensions = null;
    this.hoveredAnnotation = null;
    this.resizeHandle = false;
    this.defaultColors = ['#ff0000', '#00ff00', '#0000ff', '#000000'];
  }
  componentDidLoad() {
    if (this.autoStartScreenshot) {
      // Show the editor UI and start screenshot capture
      this.showCanvasEditor = true;
      setTimeout(() => {
        this.openScreenShot();
      }, 100); // Small delay to ensure component is fully rendered
    }
    else if (this.existingScreenshot) {
      // Show editor with existing screenshot data
      this.originalImageData = this.existingScreenshot;
      this.showCanvasEditor = true;
      setTimeout(() => {
        this.initializeCanvas();
      }, 100);
    }
    // Add window resize listener for canvas adaptation
    this.handleWindowResize = this.handleWindowResize.bind(this);
    window.addEventListener('resize', this.handleWindowResize);
  }
  disconnectedCallback() {
    // Clean up resize listener
    window.removeEventListener('resize', this.handleWindowResize);
  }
  async captureViewportScreenshot() {
    try {
      // Check if Screen Capture API is supported
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        throw new Error('Screen Capture API is not supported in this browser');
      }
      // Request screen capture with preference for current tab
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          mediaSource: 'screen',
          width: { ideal: window.innerWidth },
          height: { ideal: window.innerHeight }
        },
        audio: false,
        preferCurrentTab: true
      });
      // Create video element to capture frame
      const video = document.createElement('video');
      video.srcObject = stream;
      video.autoplay = true;
      video.muted = true;
      return new Promise((resolve, reject) => {
        video.onloadedmetadata = () => {
          video.play();
          // Wait a moment for video to stabilize
          setTimeout(() => {
            try {
              // Create canvas to capture frame
              const canvas = document.createElement('canvas');
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(video, 0, 0);
              // Stop the stream
              stream.getTracks().forEach(track => track.stop());
              // Convert to data URL
              const dataUrl = canvas.toDataURL('image/png');
              console.log('Screenshot captured successfully using Screen Capture API');
              resolve(dataUrl);
            }
            catch (error) {
              stream.getTracks().forEach(track => track.stop());
              reject(error);
            }
          }, 100);
        };
        video.onerror = () => {
          stream.getTracks().forEach(track => track.stop());
          reject(new Error('Failed to load video for screenshot capture'));
        };
      });
    }
    catch (error) {
      console.error('Screen capture failed:', error);
      throw error;
    }
  }
  render() {
    var _a, _b, _c, _d, _e, _f;
    return (h("div", { class: "canvas-editor-wrapper" }, this.showCanvasEditor && (h("div", { class: "canvas-editor-overlay" }, h("div", { class: "canvas-editor-modal" }, h("div", { class: "canvas-editor-header" }, h("div", { class: "canvas-editor-title" }, h("h3", null, this.canvasEditorTitle)), h("div", { class: "canvas-editor-toolbar" }, h("div", { class: "toolbar-section" }, h("div", { class: "tool-group" }, h("button", { class: `tool-btn ${this.canvasDrawingTool === 'rectangle' ? 'active' : ''}`, onClick: () => this.canvasDrawingTool = 'rectangle', title: "Rectangle" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "lucide lucide-square" }, h("rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }))), h("button", { class: `tool-btn ${this.canvasDrawingTool === 'line' ? 'active' : ''}`, onClick: () => this.canvasDrawingTool = 'line', title: "Line" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "lucide lucide-minus" }, h("path", { d: "M5 12h14" }))), h("button", { class: `tool-btn ${this.canvasDrawingTool === 'arrow' ? 'active' : ''}`, onClick: () => this.canvasDrawingTool = 'arrow', title: "Arrow" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "lucide lucide-move-up-right" }, h("path", { d: "M13 5H19V11" }), h("path", { d: "M19 5L5 19" }))), h("button", { class: `tool-btn ${this.canvasDrawingTool === 'text' ? 'active' : ''}`, onClick: () => this.canvasDrawingTool = 'text', title: "Text" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "lucide lucide-type" }, h("path", { d: "M12 4v16" }), h("path", { d: "M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2" }), h("path", { d: "M9 20h6" }))), h("div", { class: "toolbar-divider" }), h("button", { class: "tool-btn undo-btn", onClick: this.undoLastAnnotation, disabled: this.annotations.length === 0, title: "Undo" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "lucide lucide-undo" }, h("path", { d: "M3 7v6h6" }), h("path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" }))), this.selectedAnnotation && (h("button", { class: "tool-btn delete-btn", onClick: this.deleteSelectedAnnotation, title: "Delete" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "lucide lucide-trash-2" }, h("path", { d: "M3 6h18" }), h("path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" }), h("path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" }), h("line", { x1: "10", x2: "10", y1: "11", y2: "17" }), h("line", { x1: "14", x2: "14", y1: "11", y2: "17" })))))), h("div", { class: "toolbar-section" }, h("div", { class: "color-palette" }, this.defaultColors.map((color, index) => (h("div", { class: "color-slot-wrapper" }, h("button", { class: `color-btn ${this.canvasDrawingColor === color ? 'active' : ''} ${this.editingColorIndex === index ? 'editing' : ''}`, style: { backgroundColor: color }, onClick: () => this.handleColorSlotClick(index), title: `Color ${index + 1} - Click to customize` }, this.editingColorIndex === index && (h("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "white", "stroke-width": "2" }, h("path", { d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z" })))), this.editingColorIndex === index && this.showColorPicker && (h("div", { class: "color-picker-dropdown" }, h("input", { type: "color", value: color, onInput: (e) => this.handleColorPickerInput(e), onClick: (e) => this.handleColorPickerClick(e) })))))))), (this.selectedAnnotation || this.canvasDrawingTool) && (h("div", { class: "toolbar-section selected-annotation-controls" }, (((_a = this.selectedAnnotation) === null || _a === void 0 ? void 0 : _a.type) === 'text' || (!this.selectedAnnotation && this.canvasDrawingTool === 'text')) && (h("div", { class: "text-controls" }, h("div", { class: "font-size-control" }, h("label", null, this.sizeLabelText), h("input", { type: "range", min: "8", max: "72", value: ((_b = this.selectedAnnotation) === null || _b === void 0 ? void 0 : _b.fontSize) || this.canvasTextSize, onInput: (e) => {
        const newSize = parseInt(e.target.value);
        if (this.selectedAnnotation) {
          this.updateSelectedTextSize(newSize);
        }
        else {
          this.canvasTextSize = newSize;
        }
      }, class: "size-slider" }), h("span", { class: "size-value" }, ((_c = this.selectedAnnotation) === null || _c === void 0 ? void 0 : _c.fontSize) || this.canvasTextSize, "px")), this.selectedAnnotation && (h("button", { class: "action-btn small", onClick: () => this.startTextEditing(this.selectedAnnotation) }, this.editTextButtonText)))), ((['rectangle', 'line', 'arrow'].includes((_d = this.selectedAnnotation) === null || _d === void 0 ? void 0 : _d.type)) ||
      (!this.selectedAnnotation && ['rectangle', 'line', 'arrow'].includes(this.canvasDrawingTool))) && (h("div", { class: "shape-controls" }, h("div", { class: "border-width-control" }, h("label", null, this.borderLabelText), h("input", { type: "range", min: "1", max: "20", value: ((_e = this.selectedAnnotation) === null || _e === void 0 ? void 0 : _e.lineWidth) || this.canvasLineWidth, onInput: (e) => {
        const newWidth = parseInt(e.target.value);
        if (this.selectedAnnotation) {
          this.updateSelectedBorderWidth(newWidth);
        }
        else {
          this.canvasLineWidth = newWidth;
        }
      }, class: "size-slider" }), h("span", { class: "size-value" }, ((_f = this.selectedAnnotation) === null || _f === void 0 ? void 0 : _f.lineWidth) || this.canvasLineWidth, "px")))))), h("div", { class: "toolbar-section" }, h("button", { class: "action-btn secondary", onClick: this.closeCanvasEditor }, this.canvasEditorCancelText), h("button", { class: "action-btn primary", onClick: this.saveAnnotations }, this.canvasEditorSaveText))), h("div", { class: "canvas-editor-content" }, h("canvas", { ref: (el) => this.canvasRef = el, class: "annotation-canvas", onMouseDown: this.handleCanvasMouseDown, onMouseMove: this.handleCanvasMouseMove, onMouseUp: this.handleCanvasMouseUp, onMouseLeave: this.handleCanvasMouseUp }))))))));
  }
};
CanvasEditor.style = canvasEditorCss;

const feedbackButtonCss = ".feedback-button-content{cursor:pointer;max-width:fit-content;letter-spacing:var(--feedback-button-letter-spacing);z-index:var(--feedback-button-z-index);font-family:var(--feedback-font-family)}.feedback-button-content--custom-font{font-family:inherit}.feedback-button-content--light{align-items:center;background-color:var(--feedback-button-light-bg-color);border-radius:var(--feedback-button-border-radius);box-shadow:rgba(60, 64, 67, 0.3) 0px 1px 2px 0px, rgba(60, 64, 67, 0.15) 0px 2px 6px 2px;box-sizing:border-box;color:var(--feedback-button-light-text-color);display:flex;font-size:var(--feedback-button-text-font-size);font-weight:var(--feedback-button-text-font-weight);padding:8px 15px}.feedback-button-content--dark{align-items:center;background-color:var(--feedback-button-dark-bg-color);border-radius:var(--feedback-button-border-radius);box-shadow:rgba(60, 64, 67, 0.3) 0px 1px 2px 0px, rgba(60, 64, 67, 0.15) 0px 2px 6px 2px;box-sizing:border-box;color:var(--feedback-button-dark-text-color);display:flex;font-weight:var(--feedback-button-text-font-weight);font-size:var(--feedback-button-text-font-size);padding:8px 15px}.icon-edit{stroke:var(--feedback-button-light-icon-color)}.feedback-button-content--dark .icon-edit{stroke:var(--feedback-button-dark-icon-color)}.feedback-button-content--bottom-right{bottom:10px;position:fixed;right:10px}.feedback-button-content--center-right{position:fixed;transform:rotate(-90deg) translateY(-50%);top:50%}.feedback-button-content--center-right.feedback-button-content--dark,.feedback-button-content--center-right.feedback-button-content--light{border-radius:4px;border-bottom-left-radius:0px;border-bottom-right-radius:0px}.feedback-button-content-icon{height:16px;margin-right:5px;width:16px}.feedback-button-content--center-right .feedback-button-content-icon{rotate:90deg}@media screen and (max-width: 767px){.feedback-button-content--hide-mobile{display:none}}";

const FeedbackButton = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.feedbackSent = createEvent(this, "feedbackSent", 7);
    this.feedbackError = createEvent(this, "feedbackError", 7);
    this.buttonPosition = 'default';
    this.buttonStyle = 'default';
    this.hideIcon = false;
    this.hideMobile = false;
    this.sessionId = '';
    this.metadata = '';
    this.submit = false;
    this.customFont = false;
    this.emailAddress = '';
    this.isEmailRequired = false;
    this.fetchData = true;
    this.hideEmail = false;
    this.hidePrivacyPolicy = true;
    this.hideRating = false;
    this.hideScreenshotButton = false;
    this.modalPosition = 'center';
    this.project = '';
    this.rating = undefined;
    this.ratingMode = 'thumbs';
    this.emailPlaceholder = 'Email address (optional)';
    this.errorMessage = 'Please try again later.';
    this.errorMessage403 = 'The request URL does not match the one defined in PushFeedback for this project.';
    this.errorMessage404 = 'We could not find the provided project id in PushFeedback.';
    this.footerText = '';
    this.messagePlaceholder = 'Share your thoughts...';
    this.modalTitle = 'Share your feedback';
    this.modalTitleError = 'Oops!';
    this.modalTitleSuccess = 'Thanks for your feedback!';
    this.privacyPolicyText = "I have read and expressly consent to the terms of the <a href='https://pushfeedback.com/privacy'>Privacy Policy</a>.";
    this.ratingPlaceholder = 'Was this page helpful?';
    this.ratingStarsPlaceholder = 'How would you rate this page?';
    this.sendButtonText = 'Send';
    this.successMessage = '';
    this.recaptchaText = 'This form is protected by reCAPTCHA and the Google <a href="https://policies.google.com/privacy" target="_blank" rel="noopener noreferrer">Privacy Policy</a> and <a href="https://policies.google.com/terms" target="_blank" rel="noopener noreferrer">Terms of Service</a> apply.';
    this.screenshotAttachedText = 'Screenshot attached';
    this.screenshotButtonText = 'Add a screenshot';
    this.screenshotTakingText = 'Taking screenshot...';
    this.screenshotEditTextButtonText = 'Edit text';
    this.screenshotEditorTitle = 'Edit screenshot';
    this.screenshotEditorCancelText = 'Cancel';
    this.screenshotEditorSaveText = 'Save';
    this.screenshotSizeLabelText = 'Size:';
    this.screenshotBorderLabelText = 'Border:';
    this.screenshotEditTextPromptText = 'Edit text:';
    this.screenshotErrorGeneral = 'Failed to capture screenshot.';
    this.screenshotErrorPermission = 'Permission denied. Please allow screen sharing to take screenshots.';
    this.screenshotErrorNotSupported = 'Screen capture is not supported in this browser.';
    this.screenshotErrorNotFound = 'No screen sources available for capture.';
    this.screenshotErrorCancelled = 'Screenshot capture was cancelled.';
    this.screenshotErrorBrowserNotSupported = 'Your browser does not support screen capture. Please use a browser like Chrome, Firefox, or Safari on desktop.';
    this.screenshotErrorUnexpected = 'An unexpected error occurred. Please try again.';
  }
  componentWillLoad() {
    if (!this.sessionId) {
      let storedSessionId = localStorage.getItem('pushfeedback_sessionid');
      if (!storedSessionId) {
        storedSessionId = this.generateRandomSessionId();
        localStorage.setItem('pushfeedback_sessionid', storedSessionId);
        this.sessionId = storedSessionId;
      }
    }
    else {
      localStorage.setItem('pushfeedback_sessionid', this.sessionId);
    }
  }
  componentDidLoad() {
    if (this.buttonPosition === 'center-right') {
      const buttonContent = this.el.shadowRoot.querySelector('.feedback-button-content');
      let adjustement = 0;
      if (this.isSafariBrowser()) {
        adjustement = 5;
      }
      buttonContent.style.right = `${((buttonContent.offsetWidth + adjustement) / 2) * -1}px`;
    }
    if (!this.customFont) {
      this.loadInterFont();
    }
  }
  connectedCallback() {
    this.feedbackModal = document.createElement('feedback-modal');
    const props = [
      'customFont',
      'emailAddress',
      'fetchData',
      'hideEmail',
      'hidePrivacyPolicy',
      'hideRating',
      'hideScreenshotButton',
      'isEmailRequired',
      'modalPosition',
      'project',
      'rating',
      'ratingMode',
      'screenshotEditorTitle',
      'screenshotEditorCancelText',
      'screenshotEditorSaveText',
      'screenshotEditTextButtonText',
      'screenshotSizeLabelText',
      'screenshotBorderLabelText',
      'screenshotEditTextPromptText',
      'screenshotErrorGeneral',
      'screenshotErrorPermission',
      'screenshotErrorNotSupported',
      'screenshotErrorNotFound',
      'screenshotErrorCancelled',
      'screenshotErrorBrowserNotSupported',
      'screenshotErrorUnexpected',
      'emailPlaceholder',
      'errorMessage',
      'errorMessage403',
      'errorMessage404',
      'footerText',
      'messagePlaceholder',
      'metadata',
      'modalTitle',
      'modalTitleError',
      'modalTitleSuccess',
      'privacyPolicyText',
      'ratingPlaceholder',
      'ratingStarsPlaceholder',
      'screenshotAttachedText',
      'screenshotButtonText',
      'screenshotTakingText',
      'sendButtonText',
      'successMessage',
      'recaptchaText',
    ];
    props.forEach((prop) => {
      this.feedbackModal[prop] = this[prop];
    });
    document.body.appendChild(this.feedbackModal);
  }
  disconnectedCallback() {
    document.body.removeChild(this.feedbackModal);
  }
  generateRandomSessionId(length = 16) {
    return Math.random().toString(36).substr(2, length);
  }
  isSafariBrowser() {
    const isSafari = /safari/i.test(navigator.userAgent) && !/chrome/i.test(navigator.userAgent);
    return isSafari;
  }
  loadInterFont() {
    const link = document.createElement('link');
    link.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap';
    link.rel = 'stylesheet';
    document.head.appendChild(link);
  }
  showModal() {
    if (this.submit) {
      this.submitRatingFeedback();
    }
    else {
      this.feedbackModal.openModal();
    }
  }
  async submitRatingFeedback() {
    try {
      // Get reCAPTCHA token if enabled
      let recaptchaToken = null;
      if (this.feedbackModal.recaptchaEnabled) {
        recaptchaToken = await this.feedbackModal.getRecaptchaToken();
        if (!recaptchaToken) {
          // If reCAPTCHA is enabled but token retrieval failed, emit error
          const response = {
            status: 500,
            message: 'Failed to verify reCAPTCHA. Please try again.',
          };
          this.feedbackError.emit({ error: response });
          return;
        }
      }
      const body = Object.assign({ url: window.location.href, project: this.project, rating: this.rating || -1, ratingMode: this.ratingMode, message: '', metadata: this.metadata, session: localStorage.getItem('pushfeedback_sessionid') || '' }, (recaptchaToken && { recaptchaToken }));
      const res = await fetch('https://app.pushfeedback.com/api/feedback/', {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
          'Content-Type': 'application/json',
        },
      });
      if (res.status === 201) {
        const feedback_with_id = Object.assign(Object.assign({}, body), { id: await res.json() });
        this.feedbackSent.emit({ feedback: feedback_with_id });
      }
      else if (res.status === 202) {
        const limitExceededBody = {
          message: "You received a new feedback entry. You've reached the 25 message limit for your current plan. Upgrade to continue receiving feedback.",
          id: await res.json()
        };
        this.feedbackSent.emit({ feedback: limitExceededBody });
      }
      else {
        const errorText = await res.text();
        const response = {
          status: res.status,
          message: errorText,
        };
        this.feedbackError.emit({ error: response });
      }
    }
    catch (error) {
      const response = {
        status: 500,
        message: error,
      };
      this.feedbackError.emit({ error: response });
    }
  }
  render() {
    return (h(Host, null, h("a", { class: `feedback-button-content feedback-button-content--${this.buttonStyle} feedback-button-content--${this.buttonPosition} ${this.customFont ? 'feedback-button-content--custom-font' : ''} ${this.hideMobile ? 'feedback-button-content--hide-mobile' : ''}`, onClick: () => this.showModal() }, !this.hideIcon && this.buttonStyle != 'default' && (h("span", { class: "feedback-button-content-icon" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "#fff", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "icon-edit" }, h("path", { d: "M12 20h9" }), h("path", { d: "M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" })))), h("slot", null))));
  }
  get el() { return getElement(this); }
};
FeedbackButton.style = feedbackButtonCss;

const feedbackModalCss = ".text-center{flex-grow:1;text-align:center}.feedback-modal-wrapper *{font-family:var(--feedback-font-family)}.feedback-modal-wrapper--custom-font *{font-family:inherit}.feedback-modal-wrapper{position:absolute;z-index:var(--feedback-modal-modal-wrapper-z-index)}.feedback-overlay{background-color:var(--feedback-modal-screenshot-bg-color);height:100%;left:0;opacity:0;position:fixed;top:0;width:100%;z-index:var(--feedback-modal-screnshot-z-index);transition:opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px)}.feedback-overlay--visible{opacity:1}.feedback-modal{display:inline-block;position:relative}.feedback-modal-content{background-color:var(--feedback-modal-content-bg-color);border:1px solid rgba(0, 0, 0, 0.08);border-radius:var(--feedback-modal-content-border-radius);box-shadow:0px 0px 0px 1px rgba(0, 0, 0, 0.02),\n    0px 2px 4px rgba(0, 0, 0, 0.04),\n    0px 8px 16px rgba(0, 0, 0, 0.06),\n    0px 16px 32px rgba(0, 0, 0, 0.04);box-sizing:border-box;color:var(--feedback-modal-content-text-color);display:flex;flex-direction:column;left:50%;max-width:90%;padding:24px;position:fixed;top:50%;transform:translate(-50%, -50%) scale(0.96);opacity:0;width:100%;z-index:var(--feedback-modal-content-z-index);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1)}.feedback-modal-content--open{transform:translate(-50%, -50%) scale(1);opacity:1}.feedback-modal-header{color:var(--feedback-modal-header-text-color);display:flex;font-size:var(--feedback-modal-header-font-size);font-weight:var(--feedback-modal-header-font-weight);justify-content:space-between;align-items:flex-start;margin-bottom:24px;letter-spacing:-0.01em}.feedback-modal-header-content{flex:1}.feedback-modal-header-text{display:flex;flex-direction:column;gap:6px}.feedback-modal-title{display:block}.feedback-modal-powered-by{display:block;font-size:13px;font-weight:400;color:var(--feedback-color-gray-500);line-height:1.4}.feedback-modal-powered-by a{color:var(--feedback-modal-header-text-color);text-decoration:none;font-weight:500}.feedback-modal-powered-by a:hover{text-decoration:underline}.feedback-modal-header--no-content{margin-bottom:0}.feedback-modal-rating-buttons{width:100%;margin-bottom:24px;display:flex;gap:4px}.feedback-modal-rating-button{padding:0;background-color:transparent;border:transparent;margin-right:8px;cursor:pointer}.feedback-modal-rating-buttons--stars .feedback-modal-rating-button{transition:transform 0.15s ease, opacity 0.15s ease}.feedback-modal-rating-buttons--stars .feedback-modal-rating-button:hover{transform:scale(1.1)}.feedback-modal-rating-buttons--thumbs .feedback-modal-rating-button{border:1.5px solid var(--feedback-modal-button-border-color);border-radius:var(--feedback-modal-button-border-radius);color:var(--feedback-modal-button-text-color);font-size:var(--feedback-modal-button-font-size);font-weight:500;margin-right:12px;justify-content:center;padding:10px 16px;transition:all 0.2s cubic-bezier(0.4, 0, 0.2, 1);box-shadow:0 1px 2px rgba(0, 0, 0, 0.04)}.feedback-modal-rating-buttons--thumbs .feedback-modal-rating-button:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(0, 0, 0, 0.12)}.feedback-modal-rating-buttons--thumbs .feedback-modal-rating-button:hover,.feedback-modal-rating-buttons--thumbs .feedback-modal-rating-button--selected{background-color:var(--feedback-modal-button-bg-color-active);border:1.5px solid var(--feedback-modal-button-border-color-active);color:var(--feedback-modal-button-text-color-active)}.feedback-modal-rating-buttons--thumbs .feedback-modal-rating-button:hover svg,.feedback-modal-rating-buttons--thumbs .feedback-modal-rating-button--selected svg{stroke:var(--feedback-modal-rating-button-selected-color)}.feedback-modal-rating-buttons svg{stroke:var(--feedback-modal-rating-button-color);cursor:pointer}.feedback-modal-rating-buttons--stars .feedback-modal-rating-button--selected svg{fill:var(--feedback-modal-rating-button-stars-selected-color);stroke:var(--feedback-modal-rating-button-stars-selected-color)}.feedback-modal-text textarea{background-color:var(--feedback-modal-input-bg-color);border:1.5px solid var(--feedback-modal-input-border-color);border-radius:var(--feedback-modal-input-border-radius);box-sizing:border-box;color:var(--feedback-modal-input-text-color);font-size:var(--feedback-modal-input-font-size);margin-bottom:20px;height:100px;min-height:100px;padding:12px;resize:vertical;width:100%;transition:border-color 0.2s ease, box-shadow 0.2s ease;line-height:1.5}.feedback-modal-text textarea:hover{border-color:var(--feedback-modal-input-border-color-hover)}.feedback-modal-email input{background-color:var(--feedback-modal-input-bg-color);border:1.5px solid var(--feedback-modal-input-border-color);border-radius:var(--feedback-modal-input-border-radius);box-sizing:border-box;color:var(--feedback-modal-input-text-color);font-size:var(--feedback-modal-input-font-size);margin-bottom:20px;height:44px;padding:12px;width:100%;transition:border-color 0.2s ease, box-shadow 0.2s ease}.feedback-modal-email input:hover{border-color:var(--feedback-modal-input-border-color-hover)}.feedback-modal-text textarea:-webkit-autofill,.feedback-modal-email input:-webkit-autofill,.feedback-modal-email input:-webkit-autofill:hover,.feedback-modal-email input:-webkit-autofill:focus,.feedback-modal-email input:-webkit-autofill:active{-webkit-box-shadow:0 0 0 1000px var(--feedback-modal-input-bg-color) inset !important;-webkit-text-fill-color:var(--feedback-modal-input-text-color) !important;transition:background-color 5000s ease-in-out 0s}.feedback-modal-privacy{font-size:var(--feedback-modal-input-font-size);margin-bottom:20px}.feedback-modal-text textarea:focus,.feedback-modal-email input:focus{border:1.5px solid var(--feedback-modal-input-border-color-focused);outline:none;box-shadow:0 0 0 3px rgba(59, 130, 246, 0.1)}.feedback-modal-buttons{display:flex;flex-direction:column}.feedback-modal-buttons .feedback-modal-button{margin-bottom:20px}.feedback-modal-button{align-items:center;background-color:transparent;border:1.5px solid var(--feedback-modal-button-border-color);border-radius:var(--feedback-modal-button-border-radius);color:var(--feedback-modal-button-text-color);cursor:pointer;display:flex;font-size:var(--feedback-modal-button-font-size);font-weight:500;justify-content:center;min-height:44px;padding:10px 16px;transition:all 0.2s cubic-bezier(0.4, 0, 0.2, 1);box-shadow:0 1px 2px rgba(0, 0, 0, 0.04)}.feedback-modal-button svg{margin-right:6px}.feedback-modal-button path{fill:var(--feedback-modal-button-icon-color)}.feedback-modal-button:hover path,.feedback-modal-button--active path{fill:var(--feedback-modal-button-icon-color-active)}.feedback-modal-button--submit{background-color:var(--feedback-modal-button-submit-bg-color);border:1.5px solid var(--feedback-modal-button-border-color-active);color:var(--feedback-modal-button-submit-text-color);box-shadow:0 2px 4px rgba(0, 0, 0, 0.1)}.feedback-modal-button:hover,.feedback-modal-button--active{background-color:var(--feedback-modal-button-bg-color-active);border:1.5px solid var(--feedback-modal-button-border-color-active);color:var(--feedback-modal-button-text-color-active);transform:translateY(-1px);box-shadow:0 4px 8px rgba(0, 0, 0, 0.12)}.feedback-modal-button--submit:hover{background-color:var(--feedback-modal-button-submit-bg-color-hover);border:1.5px solid var(--feedback-modal-button-submit-border-color-hover);color:var(--feedback-modal-button-submit-text-color-hover);transform:translateY(-1px);box-shadow:0 6px 12px rgba(0, 0, 0, 0.15)}.feedback-modal-button--submit:active{transform:translateY(0);box-shadow:0 2px 4px rgba(0, 0, 0, 0.1)}.feedback-modal-input-heading{display:block;font-size:14px;font-weight:500;padding-bottom:12px;color:var(--feedback-modal-header-text-color);letter-spacing:-0.01em}.feedback-modal-footer{font-size:12px;text-align:center}.feedback-modal-footer a{color:var(--feedback-modal-footer-link);font-weight:500;text-decoration:none}.feedback-logo,.feedback-footer-text{display:block;text-align:center;margin-top:5px}.feedback-footer-text{margin-top:10px;line-height:1.5}.feedback-footer-combined{display:block;text-align:center;font-size:11px;color:#666;line-height:1.5}.feedback-footer-combined a{color:#666;text-decoration:underline}.feedback-recaptcha-notice{display:block;text-align:center;margin-bottom:10px;font-size:11px;color:#666;line-height:1.4}.feedback-recaptcha-notice a{color:#666;text-decoration:underline}.feedback-modal-close{background-color:var(--feedback-modal-close-bg-color);border:0;border-radius:6px;cursor:pointer;height:32px;width:32px;margin-left:auto;padding:0;display:flex;align-items:center;justify-content:center;transition:all 0.2s ease}.feedback-modal-close:hover{background-color:rgba(0, 0, 0, 0.06);transform:scale(1.05)}.feedback-modal-close:active{transform:scale(0.95)}.feedback-modal-close svg{stroke:var(--feedback-modal-close-color)}.feedback-modal-screenshot{background-color:var(--feedback-modal-screenshot-bg-color);height:100%;left:0;position:fixed;top:0;width:100%;z-index:var(--feedback-modal-screnshot-z-index)}.feedback-modal-screenshot-header{align-items:center;background-color:var(--feedback-modal-screenshot-header-bg-color);border-radius:var(--feedback-modal-content-border-radius);box-shadow:0px 1px 2px 0px rgba(60, 64, 67, .30), 0px 2px 6px 2px rgba(60, 64, 67, .15);box-sizing:border-box;color:var(--feedback-modal-screenshot-header-text-color);cursor:pointer;display:flex;left:50%;top:20px;transform:translateX(-50%);padding:10px;position:fixed;width:max-content;z-index:var(--feedback-modal-screenshot-header-z-index)}.feedback-modal-screenshot-close{height:24px;padding-left:10px;width:24px}.feedback-modal-screenshot-close svg{stroke:var(--feedback-modal-close-color)}.feedback-modal-message{font-size:var(--feedback-modal-message-font-size);margin:0;line-height:1.6;color:var(--feedback-modal-content-text-color)}.feedback-modal-element-hover{background-color:transparent;cursor:pointer;border:1px solid var(--feedback-modal-element-hover-border-color)}.feedback-modal-element-selected{background-color:transparent;border:3px solid var(--feedback-modal-element-selected-border-color) !important;box-shadow:0 0 0 2px rgba(0, 123, 255, 0.3) !important}.screenshot-preview{display:inline-block;width:32px;height:32px;overflow:hidden;border-radius:6px;margin-right:10px;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);cursor:pointer;transition:all 0.2s cubic-bezier(0.4, 0, 0.2, 1);border:2px solid rgba(255, 255, 255, 0.8)}.screenshot-preview:hover{transform:scale(1.15);box-shadow:0 4px 8px rgba(0, 0, 0, 0.15)}.screenshot-preview img{width:100%;height:100%;object-fit:cover}.screenshot-loading{display:inline-flex;align-items:center;margin-right:8px}@media screen and (min-width: 768px){.feedback-modal-content{max-width:var(--feedback-modal-content-max-width)}.feedback-modal-content.feedback-modal-content--bottom-right{bottom:var(--feedback-modal-content-position-bottom);left:initial;right:var(--feedback-modal-content-position-right);top:initial;transform:initial}.feedback-modal-content.feedback-modal-content--bottom-left{bottom:var(--feedback-modal-content-position-bottom);left:var(--feedback-modal-content-position-left);top:initial;transform:initial}.feedback-modal-content.feedback-modal-content--top-right{right:var(--feedback-modal-content-position-right);top:var(--feedback-modal-content-position-top);transform:initial}.feedback-modal-content.feedback-modal-content--top-left{left:var(--feedback-modal-content-position-left);top:var(--feedback-modal-content-position-top);transform:initial}.feedback-modal-content.feedback-modal-content--center-left{left:5px;right:auto;top:50%;transform:translateY(-50%)}.feedback-modal-content.feedback-modal-content--center-right{left:auto;right:5px;top:50%;transform:translateY(-50%)}.feedback-modal-content.feedback-modal-content--sidebar-left.feedback-modal-content--open,.feedback-modal-content.feedback-modal-content--sidebar-right.feedback-modal-content--open{transform:translateX(0)}.feedback-modal-content.feedback-modal-content--sidebar-left{max-width:var(--feedback-modal-content-sidebar-max-width);left:0;right:auto;height:100vh;top:0;transform:translateX(-100%);transition:transform 0.5s ease-in-out;border-radius:0}.feedback-modal-content.feedback-modal-content--sidebar-right{max-width:var(--feedback-modal-content-sidebar-max-width);left:auto;right:0;height:100vh;top:0;transform:translateX(100%);transition:transform 0.5s ease-in-out;border-radius:0}.feedback-modal-text textarea{height:150px;min-height:150px}.feedback-modal-content.feedback-modal-content--bottom-right{transform:translateY(20px)}.feedback-modal-content.feedback-modal-content--bottom-right.feedback-modal-content--open{transform:translateY(0)}.feedback-modal-content.feedback-modal-content--bottom-left{transform:translateY(20px)}.feedback-modal-content.feedback-modal-content--bottom-left.feedback-modal-content--open{transform:translateY(0)}.feedback-modal-content.feedback-modal-content--top-right{transform:translateY(-20px)}.feedback-modal-content.feedback-modal-content--top-right.feedback-modal-content--open{transform:translateY(0)}.feedback-modal-content.feedback-modal-content--top-left{transform:translateY(-20px)}.feedback-modal-content.feedback-modal-content--top-left.feedback-modal-content--open{transform:translateY(0)}}@keyframes feather-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.feather-loader{animation:feather-spin 1s linear infinite;display:block}.screenshot-error-notification{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:10001;max-width:500px;width:90%;animation:slideDown 0.3s ease-out}@keyframes slideDown{from{opacity:0;transform:translateX(-50%) translateY(-20px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}.screenshot-error-content{background:#fee;border:1.5px solid #fcc;border-radius:10px;padding:14px 18px;display:flex;align-items:center;gap:12px;box-shadow:0 0 0 1px rgba(197, 48, 48, 0.05),\n    0 4px 6px rgba(0, 0, 0, 0.07),\n    0 10px 20px rgba(0, 0, 0, 0.1);color:#c53030}.screenshot-error-content svg:first-child{color:#e53e3e;flex-shrink:0}.screenshot-error-content span{flex:1;font-size:14px;line-height:1.4;font-weight:500}.error-close-btn{background:none;border:none;cursor:pointer;padding:6px;border-radius:6px;color:#c53030;flex-shrink:0;transition:all 0.2s ease;display:flex;align-items:center;justify-content:center}.error-close-btn:hover{background:rgba(197, 48, 48, 0.15);transform:scale(1.1)}.error-close-btn:active{transform:scale(0.95)}@media screen and (max-width: 768px){.feedback-modal-content{width:100vw;height:100dvh;max-width:none;border-radius:0;top:0;left:0;transform:scale(0.95);padding:24px 20px;display:flex;flex-direction:column}.feedback-modal-content--open{transform:scale(1)}.feedback-modal-buttons{display:flex;flex-direction:column;gap:12px}.feedback-modal-button--screenshot{display:none !important}.feedback-modal-button--submit{width:100%}.feedback-modal-text textarea{flex:1;min-height:120px;resize:none}}.feedback-modal-wrapper--embedded{position:relative;z-index:auto;display:block;width:100%}.feedback-modal-content--embedded{position:relative !important;left:auto !important;right:auto !important;top:auto !important;bottom:auto !important;transform:none !important;opacity:1 !important;max-width:100%;margin:0 auto;box-shadow:0 2px 8px rgba(0, 0, 0, 0.1);text-align:left}.feedback-modal-content--embedded.feedback-modal-content--open{transform:none !important}@media screen and (max-width: 768px){.feedback-modal-content--embedded{width:100%;height:auto;border-radius:var(--feedback-modal-content-border-radius);padding:24px}.feedback-modal-content--embedded .feedback-modal-button--screenshot{display:flex !important}}";

const FeedbackModal = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.feedbackSent = createEvent(this, "feedbackSent", 7);
    this.feedbackError = createEvent(this, "feedbackError", 7);
    this.onScrollDebounced = () => {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = setTimeout(() => {
        document.documentElement.classList.remove('feedback-modal-screenshot-closing');
        document.documentElement.style.top = '';
        window.removeEventListener('scroll', this.onScrollDebounced);
      }, 200);
    };
    this.handleSubmit = async (event) => {
      event.preventDefault();
      if (this.isEmailRequired && !this.formEmail) {
        return;
      }
      this.resetOverflow();
      this.showScreenshotMode = false;
      this.showScreenshotTopBar = false;
      this.showModal = false;
      this.sending = true;
      try {
        // Get reCAPTCHA token if enabled
        let recaptchaToken = null;
        if (this.recaptchaEnabled) {
          recaptchaToken = await this.getRecaptchaToken();
          if (!recaptchaToken) {
            // If reCAPTCHA is enabled but token retrieval failed, show error
            this.formSuccess = false;
            this.formError = true;
            this.formErrorStatus = 500;
            this.sending = false;
            this.showModal = true;
            return;
          }
        }
        const body = Object.assign({ url: window.location.href, message: this.formMessage, email: this.formEmail, project: this.project, screenshot: this.encodedScreenshot, rating: this.selectedRating, ratingMode: this.ratingMode, metadata: this.metadata, verification: this.formVerification, session: localStorage.getItem('pushfeedback_sessionid') || '' }, (recaptchaToken && { recaptchaToken }));
        const res = await fetch('https://app.pushfeedback.com/api/feedback/', {
          method: 'POST',
          body: JSON.stringify(body),
          headers: {
            'Content-Type': 'application/json',
          },
        });
        if (res.status === 201) {
          const feedback_with_id = Object.assign(Object.assign({}, body), { id: await res.json() });
          this.feedbackSent.emit({ feedback: feedback_with_id });
          this.formSuccess = true;
          this.formError = false;
        }
        else if (res.status === 202) {
          const limitExceededBody = {
            message: "You received a new feedback entry. You've reached the 25 message limit for your current plan. Upgrade to continue receiving feedback.",
            id: await res.json()
          };
          this.feedbackSent.emit({ feedback: limitExceededBody });
          this.formSuccess = true;
          this.formError = false;
        }
        else {
          const errorText = await res.text();
          const response = {
            status: res.status,
            message: errorText,
          };
          this.feedbackError.emit({ error: response });
          this.formSuccess = false;
          this.formError = true;
          this.formErrorStatus = res.status;
        }
      }
      catch (error) {
        const response = {
          status: 500,
          message: error,
        };
        this.feedbackError.emit({ error: response });
        this.formSuccess = false;
        this.formError = true;
        this.formErrorStatus = 500;
      }
      finally {
        this.sending = false;
        this.showModal = true;
      }
    };
    this.close = () => {
      this.isAnimating = false;
      setTimeout(() => {
        this.sending = false;
        this.showModal = false;
        this.showScreenshotMode = false;
        this.showScreenshotTopBar = false;
        this.hasSelectedElement = false;
        this.encodedScreenshot = null;
        // Remove highlight from ALL selected elements
        document.querySelectorAll('.feedback-modal-element-selected').forEach(el => {
          el.classList.remove('feedback-modal-element-selected');
        });
        // Reset form states
        this.formSuccess = false;
        this.formError = false;
        this.formErrorStatus = 500;
        this.formMessage = '';
        this.formEmail = '';
        this.resetOverflow();
      }, 200);
    };
    // Handle screenshot events from canvas editor
    this.handleScreenshotReady = (event) => {
      this.encodedScreenshot = event.detail.screenshot;
      this.showModal = true;
      this.takingScreenshot = false;
      this.showCanvasEditor = false;
      this.autoStartCapture = false;
    };
    this.handleScreenshotCancelled = () => {
      this.showModal = true;
      this.takingScreenshot = false;
      this.showCanvasEditor = false;
      this.autoStartCapture = false;
    };
    this.handleScreenshotError = (event) => {
      console.error('Screenshot error:', event.detail.error);
      // Store error message to display in feedback modal
      this.screenshotError = event.detail.error;
      this.showScreenshotError = true;
      // Close canvas editor and return to feedback modal
      this.showModal = true;
      this.takingScreenshot = false;
      this.showCanvasEditor = false;
      this.autoStartCapture = false;
      // Auto-hide error after 8 seconds
      setTimeout(() => {
        this.showScreenshotError = false;
      }, 8000);
    };
    // Trigger screenshot capture
    this.openScreenShot = () => {
      this.showModal = false;
      this.takingScreenshot = true;
      this.autoStartCapture = true; // Auto-start new screenshot
      this.showCanvasEditor = true;
    };
    // Open canvas editor for existing screenshot
    this.openCanvasEditor = (event) => {
      if (event) {
        event.stopPropagation();
      }
      this.showModal = false;
      this.autoStartCapture = false; // Don't auto-start, just edit existing
      this.showCanvasEditor = true;
    };
    this.sending = false;
    this.formMessage = '';
    this.formEmail = '';
    this.formSuccess = false;
    this.formVerification = '';
    this.formError = false;
    this.formErrorStatus = 500;
    this.encodedScreenshot = undefined;
    this.isPrivacyChecked = false;
    this.whitelabel = false;
    this.selectedRating = -1;
    this.overlayVisible = false;
    this.isAnimating = false;
    this.recaptchaEnabled = false;
    this.recaptchaSiteKey = null;
    this.takingScreenshot = false;
    this.showScreenshotError = false;
    this.screenshotError = '';
    this.showCanvasEditor = false;
    this.autoStartCapture = false;
    this.customFont = false;
    this.emailAddress = '';
    this.hideEmail = false;
    this.isEmailRequired = false;
    this.ratingMode = 'thumbs';
    this.hasSelectedElement = false;
    this.hidePrivacyPolicy = true;
    this.hideRating = false;
    this.hideScreenshotButton = false;
    this.project = '';
    this.showScreenshotMode = false;
    this.showScreenshotTopBar = false;
    this.showModal = false;
    this.rating = undefined;
    this.metadata = undefined;
    this.fetchData = true;
    this.embedded = false;
    this.emailPlaceholder = 'Email address (optional)';
    this.errorMessage = 'Please try again later.';
    this.errorMessage403 = 'The request URL does not match the one defined in PushFeedback for this project.';
    this.errorMessage404 = 'We could not find the provided project ID in PushFeedback.';
    this.messagePlaceholder = 'Share your thoughts...';
    this.footerText = '';
    this.modalPosition = 'center';
    this.modalTitle = 'Share your feedback';
    this.modalTitleError = 'Oops!';
    this.modalTitleSuccess = 'Thanks for your feedback!';
    this.privacyPolicyText = "I have read and expressly consent to the terms of the <a href='https://pushfeedback.com/privacy'>Privacy Policy</a>.";
    this.ratingPlaceholder = 'Was this page helpful?';
    this.ratingStarsPlaceholder = 'How would you rate this page?';
    this.sendButtonText = 'Send';
    this.successMessage = '';
    this.recaptchaText = 'This form is protected by reCAPTCHA and the Google <a href="https://policies.google.com/privacy" target="_blank" rel="noopener noreferrer">Privacy Policy</a> and <a href="https://policies.google.com/terms" target="_blank" rel="noopener noreferrer">Terms of Service</a> apply.';
    this.screenshotAttachedText = 'Screenshot attached';
    this.screenshotButtonText = 'Add a screenshot';
    this.screenshotTakingText = 'Taking screenshot...';
    this.screenshotEditTextButtonText = 'Edit text';
    this.screenshotEditorTitle = 'Edit screenshot';
    this.screenshotEditorCancelText = 'Cancel';
    this.screenshotEditorSaveText = 'Save';
    this.screenshotSizeLabelText = 'Size:';
    this.screenshotBorderLabelText = 'Border:';
    this.screenshotEditTextPromptText = 'Edit text:';
    this.screenshotErrorGeneral = 'Failed to capture screenshot.';
    this.screenshotErrorPermission = 'Permission denied. Please allow screen sharing to take screenshots.';
    this.screenshotErrorNotSupported = 'Screen capture is not supported in this browser.';
    this.screenshotErrorNotFound = 'No screen sources available for capture.';
    this.screenshotErrorCancelled = 'Screenshot capture was cancelled.';
    this.screenshotErrorBrowserNotSupported = 'Your browser does not support screen capture. Please use a browser like Chrome, Firefox, or Safari on desktop.';
    this.screenshotErrorUnexpected = 'An unexpected error occurred. Please try again.';
  }
  componentWillLoad() {
    if (this.fetchData)
      this.fetchProjectData();
    this.formEmail = this.emailAddress;
    if (this.rating) {
      this.selectedRating = this.rating;
    }
    if (this.ratingMode == 'thumbs' && this.rating == 0) {
      this.selectedRating = 5;
    }
    // Automatically show modal when embedded
    if (this.embedded) {
      this.showModal = true;
    }
  }
  async fetchProjectData() {
    try {
      const response = await fetch('https://app.pushfeedback.com/api/projects/' + this.project + '/');
      const data = await response.json();
      this.whitelabel = data.whitelabel;
      this.recaptchaEnabled = data.recaptcha_enabled || false;
      this.recaptchaSiteKey = data.recaptcha_site_key || null;
      // Load reCAPTCHA script if enabled
      if (this.recaptchaEnabled && this.recaptchaSiteKey) {
        this.loadRecaptchaScript();
      }
    }
    catch (error) {
      console.log(error);
    }
  }
  loadRecaptchaScript() {
    // Check if script already loaded
    if (document.querySelector('script[src*="google.com/recaptcha"]')) {
      return;
    }
    const script = document.createElement('script');
    script.src = `https://www.google.com/recaptcha/api.js?render=${this.recaptchaSiteKey}`;
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);
  }
  async getRecaptchaToken() {
    if (!this.recaptchaEnabled || !this.recaptchaSiteKey) {
      return null;
    }
    try {
      // Wait for grecaptcha to be available
      let attempts = 0;
      while (!window['grecaptcha'] && attempts < 50) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
      if (!window['grecaptcha']) {
        console.error('reCAPTCHA script not loaded');
        return null;
      }
      // Use ready() to ensure grecaptcha is fully initialized before executing
      return await new Promise((resolve, reject) => {
        window['grecaptcha'].ready(async () => {
          try {
            const token = await window['grecaptcha'].execute(this.recaptchaSiteKey, {
              action: 'submit_feedback'
            });
            resolve(token);
          }
          catch (error) {
            console.error('reCAPTCHA execution error:', error);
            reject(error);
          }
        });
      });
    }
    catch (error) {
      console.error('reCAPTCHA error:', error);
      return null;
    }
  }
  resetOverflow() {
    // Just clean up any stray classes, don't add/remove during screenshot
    document.documentElement.classList.remove('feedback-modal-screenshot-open');
    document.documentElement.classList.remove('feedback-modal-screenshot-open--scroll');
    document.documentElement.classList.remove('feedback-modal-screenshot-closing');
  }
  handleMessageInput(event) {
    this.formMessage = event.target.value;
  }
  handleEmailInput(event) {
    this.formEmail = event.target.value;
  }
  handleCheckboxChange(event) {
    this.isPrivacyChecked = event.target.checked;
  }
  handleVerification(event) {
    this.formVerification = event.target.value;
  }
  handleRatingChange(newRating) {
    this.selectedRating = newRating;
  }
  render() {
    return (h("div", { class: `feedback-modal-wrapper ${this.customFont ? 'feedback-modal-wrapper--custom-font' : ''} ${this.embedded ? 'feedback-modal-wrapper--embedded' : ''}` }, this.showCanvasEditor && (h("canvas-editor", { ref: (el) => this.canvasEditorRef = el, "canvas-editor-title": this.screenshotEditorTitle, "canvas-editor-cancel-text": this.screenshotEditorCancelText, "canvas-editor-save-text": this.screenshotEditorSaveText, "screenshot-taking-text": this.screenshotTakingText, "screenshot-attached-text": this.screenshotAttachedText, "screenshot-button-text": this.screenshotButtonText, "auto-start-screenshot": this.autoStartCapture, "existing-screenshot": this.encodedScreenshot || '', "edit-text-button-text": this.screenshotEditTextButtonText, "size-label-text": this.screenshotSizeLabelText, "border-label-text": this.screenshotBorderLabelText, "edit-text-prompt-text": this.screenshotEditTextPromptText, "screenshot-error-general": this.screenshotErrorGeneral, "screenshot-error-permission": this.screenshotErrorPermission, "screenshot-error-not-supported": this.screenshotErrorNotSupported, "screenshot-error-not-found": this.screenshotErrorNotFound, "screenshot-error-cancelled": this.screenshotErrorCancelled, "screenshot-error-browser-not-supported": this.screenshotErrorBrowserNotSupported, "screenshot-error-unexpected": this.screenshotErrorUnexpected, onScreenshotReady: this.handleScreenshotReady, onScreenshotCancelled: this.handleScreenshotCancelled, onScreenshotFailed: this.handleScreenshotError })), this.showScreenshotError && (h("div", { class: "screenshot-error-notification" }, h("div", { class: "screenshot-error-content" }, h("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, h("circle", { cx: "12", cy: "12", r: "10" }), h("line", { x1: "15", y1: "9", x2: "9", y2: "15" }), h("line", { x1: "9", y1: "9", x2: "15", y2: "15" })), h("span", null, this.screenshotError), h("button", { class: "error-close-btn", onClick: () => this.showScreenshotError = false, title: "Close" }, h("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, h("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), h("line", { x1: "6", y1: "6", x2: "18", y2: "18" })))))), this.showModal && !this.embedded && (h("div", { class: `feedback-overlay ${this.isAnimating ? 'feedback-overlay--visible' : ''}` })), this.showModal && (h("div", { class: `feedback-modal-content feedback-modal-content--${this.modalPosition} ${this.isAnimating ? 'feedback-modal-content--open' : ''} ${this.embedded ? 'feedback-modal-content--embedded' : ''}`, ref: (el) => (this.modalContent = el) }, h("div", { class: `feedback-modal-header ${(this.formSuccess && !this.successMessage) || (this.formError && !this.errorMessage) ? 'feedback-modal-header--no-content' : ''}` }, h("div", { class: "feedback-modal-header-content" }, !this.formSuccess && !this.formError ? (h("div", { class: "feedback-modal-header-text" }, h("span", { class: "feedback-modal-title" }, this.modalTitle), !this.whitelabel && (h("span", { class: "feedback-modal-powered-by" }, "Powered by", ' ', h("a", { target: "_blank", href: "https://pushfeedback.com" }, "PushFeedback"))))) : this.formSuccess ? (h("span", { class: "feedback-modal-title" }, this.modalTitleSuccess)) : (h("span", { class: "feedback-modal-title" }, this.modalTitleError))), !this.embedded && (h("button", { class: "feedback-modal-close", onClick: this.close }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "22", height: "22", viewBox: "0 0 24 24", fill: "none", stroke: "#191919", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-x" }, h("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), h("line", { x1: "6", y1: "6", x2: "18", y2: "18" }))))), h("div", { class: "feedback-modal-body" }, !this.formSuccess && !this.formError ? (h("form", { onSubmit: this.handleSubmit }, !this.hideRating && (h("div", { class: "feedback-modal-rating" }, this.ratingMode === 'thumbs' ? (h("div", { class: "feedback-modal-rating-content" }, h("span", { class: "feedback-modal-input-heading" }, this.ratingPlaceholder), h("div", { class: "feedback-modal-rating-buttons feedback-modal-rating-buttons--thumbs" }, h("button", { title: "Yes", class: `feedback-modal-rating-button ${this.selectedRating === 1
        ? 'feedback-modal-rating-button--selected'
        : ''}`, onClick: (event) => {
        event.preventDefault();
        this.handleRatingChange(1);
      } }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "#5F6368", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, h("path", { d: "M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3" }))), h("button", { title: "No", class: `feedback-modal-rating-button ${this.selectedRating === 5
        ? 'feedback-modal-rating-button--selected'
        : ''}`, onClick: (event) => {
        event.preventDefault();
        this.handleRatingChange(5);
      } }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "#5F6368", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, h("path", { d: "M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17" })))))) : (h("div", { class: "feedback-modal-rating-content" }, h("span", { class: "feedback-modal-input-heading" }, this.ratingStarsPlaceholder), h("div", { class: "feedback-modal-rating-buttons feedback-modal-rating-buttons--stars" }, [1, 2, 3, 4, 5].map((rating) => (h("button", { key: rating, class: `feedback-modal-rating-button ${this.selectedRating >= rating
        ? 'feedback-modal-rating-button--selected'
        : ''}`, onClick: (event) => {
        event.preventDefault();
        this.handleRatingChange(rating);
      } }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 24 24", fill: "none", stroke: "#5F6368", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, h("polygon", { points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" })))))))))), h("div", { class: "feedback-modal-text" }, h("textarea", { placeholder: this.messagePlaceholder, value: this.formMessage, onInput: (event) => this.handleMessageInput(event) })), !this.hideEmail && (h("div", { class: "feedback-modal-email" }, h("input", { placeholder: this.emailPlaceholder, type: "email", onInput: (event) => this.handleEmailInput(event), value: this.formEmail, required: this.isEmailRequired }))), h("div", { class: "feedback-verification" }, h("input", { type: "text", name: "verification", style: { display: 'none' }, onInput: (event) => this.handleVerification(event), value: this.formVerification })), !this.hidePrivacyPolicy && (h("div", { class: "feedback-modal-privacy" }, h("input", { type: "checkbox", id: "privacyPolicy", onChange: (ev) => this.handleCheckboxChange(ev), required: true }), h("span", { innerHTML: this.privacyPolicyText }))), h("div", { class: `feedback-modal-buttons ${this.hideScreenshotButton ? 'single' : ''}` }, !this.hideScreenshotButton && (h("button", { type: "button", class: `feedback-modal-button feedback-modal-button--screenshot ${this.encodedScreenshot ? 'feedback-modal-button--active' : ''}`, onClick: this.openScreenShot, disabled: this.sending || this.takingScreenshot }, this.encodedScreenshot && (h("div", { class: "screenshot-preview", onClick: this.openCanvasEditor }, h("img", { src: this.encodedScreenshot, alt: "Screenshot Preview" }))), !this.encodedScreenshot && !this.takingScreenshot && (h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 -960 960 960", width: "24" }, h("path", { d: "M680-80v-120H560v-80h120v-120h80v120h120v80H760v120h-80ZM200-200v-200h80v120h120v80H200Zm0-360v-200h200v80H280v120h-80Zm480 0v-120H560v-80h200v200h-80Z" }))), this.takingScreenshot && (h("div", { class: "screenshot-loading" }, h("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "#666", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather-loader" }, h("line", { x1: "12", y1: "2", x2: "12", y2: "6" }), h("line", { x1: "12", y1: "18", x2: "12", y2: "22" }), h("line", { x1: "4.93", y1: "4.93", x2: "7.76", y2: "7.76" }), h("line", { x1: "16.24", y1: "16.24", x2: "19.07", y2: "19.07" }), h("line", { x1: "2", y1: "12", x2: "6", y2: "12" }), h("line", { x1: "18", y1: "12", x2: "22", y2: "12" }), h("line", { x1: "4.93", y1: "19.07", x2: "7.76", y2: "16.24" }), h("line", { x1: "16.24", y1: "7.76", x2: "19.07", y2: "4.93" })))), this.takingScreenshot ? this.screenshotTakingText :
      this.encodedScreenshot ? this.screenshotAttachedText : this.screenshotButtonText)), h("button", { class: "feedback-modal-button feedback-modal-button--submit", type: "submit", disabled: this.sending }, this.sendButtonText)))) : this.formSuccess && !this.formError ? (h("div", { class: "feedback-modal-success" }, h("p", { class: "feedback-modal-message" }, this.successMessage))) : this.formError && this.formErrorStatus == 404 ? (h("p", { class: "feedback-modal-message" }, this.errorMessage404)) : this.formError && this.formErrorStatus == 403 ? (h("p", { class: "feedback-modal-message" }, this.errorMessage403)) : this.formError ? (h("p", { class: "feedback-modal-message" }, this.errorMessage)) : (h("span", null))), !this.formSuccess && !this.formError && (this.recaptchaEnabled || this.footerText) && (h("div", { class: "feedback-modal-footer" }, h("div", { class: "feedback-footer-combined" }, this.recaptchaEnabled && (h("span", { innerHTML: this.recaptchaText })), this.recaptchaEnabled && this.footerText && ' ', this.footerText && (h("span", { innerHTML: this.footerText })))))))));
  }
  componentDidRender() {
    if (this.showModal) {
      requestAnimationFrame(() => {
        this.overlayVisible = true;
      });
    }
  }
  async openModal() {
    this.showModal = true;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        this.isAnimating = true;
      });
    });
  }
};
FeedbackModal.style = feedbackModalCss;

export { CanvasEditor as canvas_editor, FeedbackButton as feedback_button, FeedbackModal as feedback_modal };
